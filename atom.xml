<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山城冰荔枝</title>
  
  
  <link href="http://blog.ioimp.top/atom.xml" rel="self"/>
  
  <link href="http://blog.ioimp.top/"/>
  <updated>2024-03-04T02:26:48.742Z</updated>
  <id>http://blog.ioimp.top/</id>
  
  <author>
    <name>山城冰荔枝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue中v-for中key的作用</title>
    <link href="http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-for%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-for%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2023-12-23T08:18:16.000Z</published>
    <updated>2024-03-04T02:26:48.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Vue中，v-for指令用于循环渲染列表。当Vue重新渲染列表时，它会尽可能地复用已经存在的DOM元素，而不是重新创建它们，以提高性能。这个过程中，key属性起到了关键的作用。</p><h2 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h2><p>key是用来唯一标识每个节点的特殊属性，它的作用主要有以下几点：</p><ol><li>帮助Vue跟踪每个节点的身份，从而高效地更新虚拟DOM。</li><li>识别每个节点的变化，以便复用或重新排序已经存在的元素。</li><li>提供更好的用户体验，避免出现一些奇怪的渲染效果。</li></ol><h2 id="有key和无key的区别"><a href="#有key和无key的区别" class="headerlink" title="有key和无key的区别"></a>有key和无key的区别</h2><p>在v-for中，如果不提供key属性，Vue会默认使用节点的索引作为key。然而，这样做可能会导致一些问题。</p><ol><li><p>重新排序：当列表中的元素发生顺序变化时，如果没有提供key，Vue会按照节点的顺序进行重新渲染。这可能会导致一些错误的渲染效果，因为Vue会错误地认为某个节点被移除了，而实际上只是顺序发生了变化。</p></li><li><p>输入框问题：当列表中包含了输入框等用户交互元素时，如果没有提供key，Vue会无法正确地跟踪每个输入框的状态。这可能会导致用户输入的数据丢失或者出现奇怪的渲染效果。</p></li></ol><h2 id="diff如何处理有key和无key的情况"><a href="#diff如何处理有key和无key的情况" class="headerlink" title="diff如何处理有key和无key的情况"></a>diff如何处理有key和无key的情况</h2><p>Vue的diff算法会根据节点的key属性来判断节点的变化情况，从而进行相应的更新操作。</p><ol><li><p>有key的情况：当节点有key时，Vue会根据key的变化来判断节点的身份，从而复用或重新渲染已经存在的元素。</p></li><li><p>无key的情况：当节点没有key时，Vue会按照节点的顺序进行重新渲染。如果节点的顺序发生了变化，Vue会错误地判断某个节点被移除了，从而导致错误的渲染效果。</p></li></ol><p>因此，为了避免出现问题，我们应该始终为v-for中的元素提供一个唯一的key。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Vue中，v-for指令用于循环渲染列表。key属性在v-for中的作用非常重要，它帮助Vue跟踪每个节点的身份，识别每个节点的变化，并提供更好的用户体验。如果没有提供key，Vue会按照节点的顺序进行重新渲染，可能导致一些错误的渲染效果。因此，我们应该始终为v-for中的元素提供一个唯一的key，以确保正常的渲染和用户交互体验。<br><img src="/images/image20.png"><br>参考文献：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/list.html">Vue官方文档 - 列表渲染</a></li><li><a href="https://www.jianshu.com/p/ea9b1b8e2a18">Vue.js中key的作用</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue中虚拟DOM和diff算法</title>
    <link href="http://blog.ioimp.top/2023/12/23/Vue%E4%B8%AD%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.ioimp.top/2023/12/23/Vue%E4%B8%AD%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</id>
    <published>2023-12-23T08:01:33.000Z</published>
    <updated>2024-03-04T02:26:48.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue中虚拟DOM和diff算法"><a href="#Vue中虚拟DOM和diff算法" class="headerlink" title="Vue中虚拟DOM和diff算法"></a>Vue中虚拟DOM和diff算法</h1><p>在Vue中，虚拟DOM和diff算法是两个核心概念。虚拟DOM是一种将真实DOM映射到内存中的数据结构，通过对比新旧虚拟DOM的差异，可以最小化地更新真实DOM，提高性能和效率。</p><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM是一个轻量级的JavaScript对象，它包含了对应真实DOM节点的所有属性和内容。通过使用虚拟DOM，Vue可以将组件的状态和UI分离，实现更高效的渲染。</p><p>在Vue中，当组件的状态发生变化时，Vue会重新生成一个新的虚拟DOM树。然后通过diff算法对比新旧虚拟DOM树的差异，并将差异应用到真实DOM上，从而更新页面。</p><h2 id="虚拟DOM的本质"><a href="#虚拟DOM的本质" class="headerlink" title="虚拟DOM的本质"></a>虚拟DOM的本质</h2><p>虚拟DOM本质是一个轻量级的JavaScript<strong>对象</strong>，它是对真实DOM的一种抽象表示。虚拟DOM具有与真实DOM相同的结构和属性，但它存在于内存中而不是在浏览器中显示。</p><p>虚拟DOM的本质是通过JavaScript对象来模拟真实DOM的结构和属性。每个虚拟DOM节点都包含了节点类型、节点属性、节点内容和子节点等信息。通过使用虚拟DOM，可以将组件的状态和UI分离，实现更高效的渲染。</p><p>虚拟DOM转换成真实DOM的过程可以概括为以下几个步骤：</p><ol><li>初始渲染：当组件首次渲染时，Vue会根据组件的模板生成初始的虚拟DOM树。</li><li>虚拟DOM更新：当组件的状态发生变化时，Vue会重新生成一个新的虚拟DOM树。</li><li>Diff算法对比：Vue会使用Diff算法对比新旧虚拟DOM树的差异，找出需要更新的部分。</li><li>更新真实DOM：根据差异，Vue会将需要更新的部分转换成真实DOM的操作，如添加、删除或更新节点。</li><li>更新完成：完成真实DOM的更新后，页面会显示最新的内容。</li></ol><p>虚拟DOM转换成真实DOM的过程是在内存中进行的，只有最终的更新操作才会应用到真实的浏览器DOM上。这种方式可以最小化对真实DOM的操作，减少页面的重绘和回流，提高性能和效率。</p><p>总结来说，虚拟DOM本质是一个JavaScript对象，用于模拟真实DOM的结构和属性。虚拟DOM转换成真实DOM的过程是通过Diff算法对比新旧虚拟DOM树的差异，并将差异应用到真实DOM上。这种方式可以最小化对真实DOM的操作，提高性能和效率。</p><h2 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h2><p>Diff算法是虚拟DOM的核心算法，用于对比新旧虚拟DOM树的差异。Vue使用了一种高效的diff算法来最小化更新操作，提高性能。</p><p>Diff算法的基本思想是通过逐层对比新旧虚拟DOM树的节点，找出差异，并将差异应用到真实DOM上。在对比过程中，Diff算法会尽量复用节点，减少创建和销毁节点的开销。</p><p>Diff算法的过程可以概括为以下几个步骤：</p><ol><li>比较两棵树的根节点，如果类型不同，则直接替换整个节点。</li><li>如果类型相同，则比较节点的属性和内容。</li><li>如果属性和内容相同，则比较子节点。</li><li>如果子节点不同，则按照以下策略对子节点进行操作：<ul><li>如果新节点没有子节点，则删除旧节点的子节点。</li><li>如果旧节点没有子节点，则添加新节点的子节点。</li><li>如果新旧节点都有子节点，则使用Diff算法递归对比子节点的差异。</li></ul></li></ol><p>Diff算法的核心思想是尽量减少对真实DOM的操作，只更新必要的部分，从而提高性能。通过使用虚拟DOM和Diff算法，Vue可以实现高效的渲染和更新，提供更好的用户体验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟DOM和Diff算法是Vue中的两个核心概念，通过使用虚拟DOM和Diff算法，Vue可以实现高效的渲染和更新。虚拟DOM将组件的状态和UI分离，通过对比新旧虚拟DOM的差异，最小化地更新真实DOM，提高性能和效率。Diff算法通过逐层对比新旧虚拟DOM树的节点，找出差异，并将差异应用到真实DOM上。通过使用虚拟DOM和Diff算法，Vue可以实现高效的渲染和更新，提供更好的用户体验。</p><p>参考资料：</p><ul><li><a href="https://vuejs.org/">Vue.js官方文档</a></li><li><a href="https://medium.com/vue-mastery/understanding-vues-reactivity-system-and-virtual-dom-mp-858a43f80e69">Understanding Vue’s reactivity system and virtual DOM</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>构造函数new都干了哪些事情</title>
    <link href="http://blog.ioimp.top/2023/12/23/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0new%E9%83%BD%E5%B9%B2%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
    <id>http://blog.ioimp.top/2023/12/23/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0new%E9%83%BD%E5%B9%B2%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</id>
    <published>2023-12-23T07:46:41.000Z</published>
    <updated>2024-03-04T02:26:47.070Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="当我们使用new关键字来创建一个对象时，构造函数会执行以下步骤："><a href="#当我们使用new关键字来创建一个对象时，构造函数会执行以下步骤：" class="headerlink" title="当我们使用new关键字来创建一个对象时，构造函数会执行以下步骤："></a>当我们使用<code>new</code>关键字来创建一个对象时，构造函数会执行以下步骤：</h3><ol><li>创建一个空对象。<code>new</code>关键字会创建一个空对象，并将其赋值给<code>this</code>关键字。</li><li>设置原型链。新创建的对象会被链接到其构造函数的原型对象上，这样新对象就可以访问原型对象中定义的属性和方法。</li><li>执行构造函数代码。构造函数会在新对象的上下文中执行，这样构造函数中的代码就可以操作新对象的属性和方法。</li><li>返回新对象。构造函数执行完毕后，<code>new</code>关键字会返回新创建的对象。</li></ol><h3 id="下面是一个示例构造函数的代码："><a href="#下面是一个示例构造函数的代码：" class="headerlink" title="下面是一个示例构造函数的代码："></a>下面是一个示例构造函数的代码：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); <span class="comment">// 输出：Person &#123; name: &#x27;John&#x27;, age: 25 &#125;</span></span><br></pre></td></tr></table></figure><p>在上述示例中，<code>new Person(&#39;John&#39;, 25)</code>创建了一个新的<code>Person</code>对象，并将其赋值给<code>person1</code>变量。构造函数<code>Person</code>设置了新对象的<code>name</code>和<code>age</code>属性，最后返回了新对象。</p><h3 id="实例共享函数"><a href="#实例共享函数" class="headerlink" title="实例共享函数"></a>实例共享函数</h3><p>如果我们想在每个实例中共享一个函数，而不是为每个实例创建一个新的函数副本，我们可以将该函数添加到构造函数的原型对象上。这样，所有通过构造函数创建的实例将共享同一个函数。</p><p>下面是一个示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, my name is John</span></span><br><span class="line">person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们将<code>sayHello</code>函数添加到<code>Person</code>构造函数的原型对象上。这样，所有通过<code>Person</code>构造函数创建的实例都可以访问和调用<code>sayHello</code>函数。</p><p>由于所有实例共享同一个原型对象，它们都可以访问和调用相同的函数，而不需要为每个实例创建一个新的函数副本。这样可以节省内存空间，并提高性能。</p><p>需要注意的是，原型对象上的函数可以访问实例的属性，因为它们在同一个作用域中。在函数内部，可以使用<code>this</code>关键字来引用当前实例;构造函数可以有自己的属性和方法，它们会在每次使用<code>new</code>关键字创建对象时被重新执行。这样，每个对象都会有自己的属性值，而不会共享构造函数的属性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue中v-for效率高的原因是什么</title>
    <link href="http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-for%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-for%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2023-12-23T07:39:29.000Z</published>
    <updated>2024-03-04T02:26:48.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="v-for的更新效率高的原因"><a href="#v-for的更新效率高的原因" class="headerlink" title="v-for的更新效率高的原因"></a>v-for的更新效率高的原因</h1><p>在Vue中，使用<code>v-for</code>指令进行列表渲染时，其更新效率通常较高。这是由于Vue采用了一些优化策略和算法，以提高<code>v-for</code>的性能和效率。下面将介绍一些主要的原因：</p><h2 id="1-虚拟DOM"><a href="#1-虚拟DOM" class="headerlink" title="1. 虚拟DOM"></a>1. 虚拟DOM</h2><p>Vue使用虚拟DOM（Virtual DOM）来进行更新检测和渲染。虚拟DOM是一个轻量级的JavaScript对象，用于描述真实DOM的结构和属性。Vue通过比较新旧虚拟DOM的差异，只对发生变化的部分进行更新操作，减少了不必要的DOM操作，提高了性能。</p><p>在<code>v-for</code>中，每个列表项都会对应一个虚拟DOM节点。当数据发生变化时，Vue会通过比较新旧虚拟DOM节点的差异，只更新发生变化的列表项，而不是重新渲染整个列表。</p><h2 id="2-唯一key"><a href="#2-唯一key" class="headerlink" title="2. 唯一key"></a>2. 唯一key</h2><p>在使用<code>v-for</code>时，我们需要为每个列表项指定一个唯一的<code>key</code>属性。<code>key</code>属性用于帮助Vue识别每个列表项的身份，以便准确地进行更新操作。</p><p>通过<code>key</code>属性，Vue能够追踪每个列表项的变化，精确地确定新增、删除、移动和更新的操作。这样，Vue就可以避免不必要的DOM操作，提高了更新的效率。</p><h2 id="3-数组变更方法"><a href="#3-数组变更方法" class="headerlink" title="3. 数组变更方法"></a>3. 数组变更方法</h2><p>Vue对数组变更方法进行了特殊处理，以便能够捕捉到数组的变化。当使用数组变更方法（如<code>push</code>、<code>pop</code>、<code>splice</code>等）修改数组时，Vue能够检测到这些变化，并自动更新视图。</p><p>使用数组变更方法时，Vue会对其进行代理，拦截方法的调用，并触发相应的更新操作。这样，Vue能够精确地追踪数组的变化，只更新发生变化的部分，提高了更新的效率。</p><h2 id="4-异步更新"><a href="#4-异步更新" class="headerlink" title="4. 异步更新"></a>4. 异步更新</h2><p>Vue采用异步更新策略，将多个数据变化的更新操作合并成一次更新。这样可以减少更新的次数，提高更新的效率。</p><p>当多个数据变化同时触发更新时，Vue会将这些更新操作放入一个队列中。然后，Vue会在下一个事件循环中，批量执行这些更新操作，进行一次统一的更新。</p><p>这种异步更新策略可以避免不必要的重复计算和渲染，提高了更新的效率。</p><h2 id="5-合理使用v-if和v-show"><a href="#5-合理使用v-if和v-show" class="headerlink" title="5. 合理使用v-if和v-show"></a>5. 合理使用v-if和v-show</h2><p>在使用<code>v-for</code>时，如果需要根据条件来渲染列表项，我们应该合理使用<code>v-if</code>和<code>v-show</code>指令。</p><ul><li><code>v-if</code>指令会根据条件动态地添加或移除DOM元素。如果条件不满足，列表项会被完全移除，以提高性能。</li><li><code>v-show</code>指令会通过CSS属性控制DOM元素的显示和隐藏。即使条件不满足，列表项仍然存在于DOM中，只是通过CSS隐藏起来。</li></ul><p>根据具体的场景和需求，合理使用<code>v-if</code>和<code>v-show</code>可以提高<code>v-for</code>的更新效率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Vue中的<code>v-for</code>指令在更新效率上通常较高，这得益于Vue采用的虚拟DOM、唯一key、数组变更方法、异步更新和合理使用<code>v-if</code>和<code>v-show</code>等优化策略。这些策略和算法使得Vue能够精确地追踪数据的变化，只更新发生变化的部分，提高了性能和效率。<br><img src="/images/image19.png"><br>希望本文对你理解<code>v-for</code>的高效更新有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue中v-for数组变更方法和数组非变更方法的区别</title>
    <link href="http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-for%E6%95%B0%E7%BB%84%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E7%BB%84%E9%9D%9E%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-for%E6%95%B0%E7%BB%84%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E7%BB%84%E9%9D%9E%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-12-23T07:31:31.000Z</published>
    <updated>2024-03-04T02:26:48.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Vue中，使用<code>v-for</code>指令可以遍历数组，并根据每个元素生成对应的DOM元素。在操作数组时，我们可以使用两种方法：数组变更方法和数组非变更方法。本文将详细介绍这两种方法的区别和使用场景。</p><h2 id="数组变更方法"><a href="#数组变更方法" class="headerlink" title="数组变更方法"></a>数组变更方法</h2><p>数组变更方法是指直接对原始数组进行修改的方法，如<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>和<code>reverse</code>等。这些方法会直接修改原始数组，并触发Vue的更新机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用数组变更方法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span> &#125;); <span class="comment">// 向数组末尾添加一个元素</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Banana&#x27;</span> &#125;); <span class="comment">// 替换数组中的一个元素</span></span><br></pre></td></tr></table></figure><p>使用数组变更方法时，Vue能够检测到数组的变化，并自动更新视图。这是因为Vue会对数组变更方法进行代理，拦截这些方法的调用，从而能够捕捉到数组的变化。</p><h2 id="数组非变更方法"><a href="#数组非变更方法" class="headerlink" title="数组非变更方法"></a>数组非变更方法</h2><p>数组非变更方法是指返回一个新数组的方法，而不会修改原始数组的方法，如<code>filter</code>、<code>map</code>、<code>concat</code>和<code>slice</code>等。这些方法不会直接修改原始数组，而是返回一个经过处理的新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用数组非变更方法</span></span><br><span class="line"><span class="keyword">const</span> newItems = <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> !== <span class="string">&#x27;Apple&#x27;</span>); <span class="comment">// 过滤数组中的元素</span></span><br><span class="line"><span class="keyword">const</span> mappedItems = <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span>.<span class="title function_">toUpperCase</span>()); <span class="comment">// 对数组中的元素进行映射</span></span><br></pre></td></tr></table></figure><p>使用数组非变更方法时，由于没有直接修改原始数组，Vue无法检测到数组的变化。这意味着，如果我们使用数组非变更方法来处理数组，需要手动更新Vue的视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：手动更新视图</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">items</span> = <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> !== <span class="string">&#x27;Apple&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>如果我们需要在原始数组上进行增删改操作，并希望Vue自动更新视图，应该使用数组变更方法。</li><li>如果我们需要对原始数组进行过滤、映射等操作，并希望得到一个新的数组，可以使用数组非变更方法。但需要注意，在使用数组非变更方法后，需要手动更新Vue的视图。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在Vue中，我们可以使用数组变更方法和数组非变更方法来操作数组。数组变更方法会直接修改原始数组，并触发Vue的更新机制；而数组非变更方法会返回一个新数组，需要手动更新Vue的视图。根据具体的需求，选择合适的方法来操作数组。<br><img src="/images/image18.png"><br>希望本文对你理解数组变更方法和数组非变更方法的区别有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue中js引入图片的方法</title>
    <link href="http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADjs%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADjs%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2023-12-23T07:13:23.000Z</published>
    <updated>2024-03-04T02:26:48.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Vue项目中，我们经常需要在页面中引入图片。本文将介绍在Vue中引入图片的几种方法。</p><h2 id="1-直接使用img标签"><a href="#1-直接使用img标签" class="headerlink" title="1. 直接使用img标签"></a>1. 直接使用img标签</h2><p>最简单的方法是直接使用HTML的img标签来引入图片。在Vue的模板中，我们可以使用以下方式引入图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;@/assets/image.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>@/</code>是Vue CLI中默认配置的别名，指向<code>src</code>目录。<code>assets</code>是存放静态资源的目录，可以根据实际项目结构进行调整。</p><h2 id="2-使用require引入图片"><a href="#2-使用require引入图片" class="headerlink" title="2. 使用require引入图片"></a>2. 使用require引入图片</h2><p>在Vue中，我们可以使用<code>require</code>函数来引入图片。在Vue的模板中，我们可以使用以下方式引入图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;require(&#x27;@/assets/image.png&#x27;)&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，这里使用了Vue的动态绑定语法<code>:src</code>，使得图片路径可以根据实际需要进行动态改变。</p><h2 id="3-使用import引入图片"><a href="#3-使用import引入图片" class="headerlink" title="3. 使用import引入图片"></a>3. 使用import引入图片</h2><p>在Vue的组件中，我们也可以使用ES6的<code>import</code>语法来引入图片。在Vue的组件中，我们可以使用以下方式引入图片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> image <span class="keyword">from</span> <span class="string">&#x27;@/assets/image.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">imgSrc</span>: image</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在模板中使用动态绑定语法来显示图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgSrc&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以通过<code>import</code>来引入图片，并将其赋值给组件的<code>data</code>属性，然后在模板中使用。</p><h2 id="4-使用CSS引入图片"><a href="#4-使用CSS引入图片" class="headerlink" title="4. 使用CSS引入图片"></a>4. 使用CSS引入图片</h2><p>在Vue中，我们也可以使用CSS的<code>background-image</code>属性来引入图片。在Vue的组件的样式中，我们可以使用以下方式引入图片：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.image</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;@/assets/image.png&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在模板中使用该样式类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以通过CSS的方式来引入图片。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了在Vue中引入图片的几种方法：直接使用img标签、使用require引入图片、使用import引入图片和使用CSS引入图片。根据实际项目的需求，可以选择适合的方法来引入图片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue中v-model对应不同的表单标签的处理方式</title>
    <link href="http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-model%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.ioimp.top/2023/12/23/Vue%E4%B8%ADv-model%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2023-12-23T03:15:27.000Z</published>
    <updated>2024-03-04T02:26:48.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Vue中，v-model是一个常用的指令，用于实现表单元素与Vue实例数据的双向绑定。通过v-model指令，我们可以轻松地将表单的输入值与Vue实例中的数据进行同步。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>v-model指令可以用于不同类型的表单元素，包括输入框、复选框、单选框、下拉框等。下面是v-model的基本用法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个输入框，并通过v-model指令将输入框的值与Vue实例中的<code>message</code>数据进行绑定。当用户在输入框中输入内容时，<code>message</code>数据会自动更新，同时页面上的<code>p</code>标签中也会显示出输入框的值。</p><h2 id="绑定不同类型的表单标签"><a href="#绑定不同类型的表单标签" class="headerlink" title="绑定不同类型的表单标签"></a>绑定不同类型的表单标签</h2><h3 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h3><p>对于输入框，v-model会将输入的值作为数据进行绑定。例如，我们可以将输入框的值绑定到一个字符串类型的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>对于复选框，v-model会将选中状态作为数据进行绑定。例如，我们可以将复选框的选中状态绑定到一个布尔类型的数据：</p><p>复选框在使用v-model时，可以绑定到不同类型的变量上，主要区分为布尔型和数组型。</p><h3 id="布尔型（Boolean）"><a href="#布尔型（Boolean）" class="headerlink" title="布尔型（Boolean）"></a>布尔型（Boolean）</h3><p>当复选框绑定到布尔型变量时，选中和未选中状态将直接映射到布尔值<code>true</code>和<code>false</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;isChecked&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>复选框选中状态：&#123;&#123; isChecked &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">isChecked</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>isChecked</code>是一个布尔型变量，当复选框被选中时，<code>isChecked</code>变为<code>true</code>，反之为<code>false</code>。</p><h3 id="数组型（Array）"><a href="#数组型（Array）" class="headerlink" title="数组型（Array）"></a>数组型（Array）</h3><p>当复选框绑定到数组型变量时，选中的复选框的value值会被添加到数组中，未选中的则会从数组中移除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedItems&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Item1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedItems&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Item2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedItems&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Item3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>选中的项目：&#123;&#123; selectedItems &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">selectedItems</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedItems&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Item1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedItems&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Item2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selectedItems&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Item3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>选中的项目：&#123;&#123; selectedItems &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">selectedItems</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果变量是字符串类型则所有的复选框都会被选中</p><p>在上面的例子中，<code>selectedItems</code>是一个数组型变量，当用户选中任意一个复选框时，对应的value值（例如”Item1”）会被添加到<code>selectedItems</code>数组中。如果用户取消选中，该值则会从数组中移除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当复选框绑定到布尔型变量时，其用于表示单个复选框的选中状态。</li><li>当复选框绑定到数组型变量时，用于表示多个复选框中被选中的项，并以数组的形式存储所有选中项的value值。</li></ul><p>使用哪种类型主要取决于具体的应用场景和需求。如果只需要控制单个复选框的选中状态，通常使用布尔型变量。而如果需要处理多选的情况，比如表单中的多项选择题，使用数组型变量会更加方便。</p><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><p>对于单选框，v-model会将选中的值作为数据进行绑定。例如，我们可以将单选框的选中值绑定到一个字符串类型的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;B&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">selected</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><p>对于下拉框，v-model会将选中的值作为数据进行绑定。例如，我们可以将下拉框的选中值绑定到一个字符串类型的数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;A&quot;</span>&gt;</span>Option A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;B&quot;</span>&gt;</span>Option B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">selected</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>通过v-model指令，我们可以轻松地实现表单元素与Vue实例数据的双向绑定。无论是输入框、复选框、单选框还是下拉框，都可以通过v-model指令来实现数据的同步更新。这大大简化了表单操作的代码量，并提高了开发效率。</p><p>以上是v-model的基础使用和绑定不同类型的表单标签的方式，希望对你有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS中什么是事件冒泡</title>
    <link href="http://blog.ioimp.top/2023/12/23/JS%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/"/>
    <id>http://blog.ioimp.top/2023/12/23/JS%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</id>
    <published>2023-12-22T16:33:50.000Z</published>
    <updated>2024-03-04T02:26:48.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h1><p>在JavaScript中，事件冒泡是指当一个元素上的事件被触发时，事件会从该元素开始向上冒泡至其父元素，直到最顶层的父元素。这种冒泡的行为可以让我们在处理事件时更加方便和灵活。</p><h2 id="事件冒泡的原理"><a href="#事件冒泡的原理" class="headerlink" title="事件冒泡的原理"></a>事件冒泡的原理</h2><p>事件冒泡的原理是基于DOM树的结构。在一个典型的HTML页面中，元素之间存在嵌套关系，父元素包含子元素，子元素包含孙元素，以此类推。当一个元素上发生了某个事件（比如点击事件），浏览器会首先触发该元素上的事件处理程序，然后再触发其父元素上的事件处理程序，直到最顶层的父元素。</p><h2 id="事件冒泡的应用"><a href="#事件冒泡的应用" class="headerlink" title="事件冒泡的应用"></a>事件冒泡的应用</h2><p>事件冒泡在JavaScript中有着广泛的应用。通过使用事件冒泡，我们可以方便地为多个元素添加相同的事件处理程序，而不需要分别为每个元素添加。这样可以大大简化代码并提高代码的可维护性。</p><p>另外，事件冒泡还可以实现事件委托。事件委托是指将事件处理程序绑定在父元素上，然后通过事件冒泡的机制来触发处理程序。这种方式可以减少事件处理程序的数量，从而提高性能。例如，我们可以将点击事件处理程序绑定在一个父元素上，然后通过事件冒泡来判断具体是哪个子元素被点击了，从而执行相应的操作。</p><h2 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h2><p>有时候我们希望阻止事件冒泡，即在某个元素上触发事件后，不再向上冒泡至其父元素。在JavaScript中，可以通过调用事件对象的<code>stopPropagation()</code>方法来实现。这样可以在事件处理程序中使用<code>event.stopPropagation()</code>来阻止事件冒泡。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件冒泡是JavaScript中的一种重要的事件机制，可以使我们更加方便地处理事件。通过了解事件冒泡的原理和应用，我们可以更好地运用它来编写高效的JavaScript代码。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件冒泡示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 获取父元素、子元素和按钮元素</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> child = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;child&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 为父元素、子元素和按钮元素添加点击事件处理程序</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    parent.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父元素被点击&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    child.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子元素被点击&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      event.<span class="title function_">stopPropagation</span>(); <span class="comment">// 阻止事件冒泡</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮被点击&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在上述示例代码中，我们创建了一个父元素<code>parent</code>、一个子元素<code>child</code>和一个按钮元素<code>button</code>。我们为这三个元素分别添加了点击事件处理程序。</p><p>当点击按钮时，点击事件会首先触发按钮元素上的事件处理程序，然后再冒泡至子元素和父元素。但是由于我们在按钮元素的事件处理程序中调用了<code>event.stopPropagation()</code>方法，所以事件冒泡会在按钮元素处被阻止，不再向上冒泡至子元素和父元素。因此，只会在控制台输出”按钮被点击”，而不会输出”子元素被点击”和”父元素被点击”。</p><p>这个示例展示了如何使用事件冒泡和阻止事件冒泡来处理事件。<br>希望本篇博客对你理解事件冒泡有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
    <category term="JavaScript" scheme="http://blog.ioimp.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MVVM设计模式</title>
    <link href="http://blog.ioimp.top/2023/12/23/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.ioimp.top/2023/12/23/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-22T16:19:02.000Z</published>
    <updated>2024-03-04T02:26:48.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是MVVM设计模式"><a href="#什么是MVVM设计模式" class="headerlink" title="什么是MVVM设计模式"></a>什么是MVVM设计模式</h2><p>MVVM是一种软件架构设计模式，它将应用程序的用户界面(UI)、业务逻辑和数据模型分离开来。MVVM的全称是Model-View-ViewModel，它的核心思想是将视图(View)和模型(Model)之间的依赖关系解耦，通过ViewModel来进行数据的交互和控制。</p><ul><li>Model：模型层，负责数据的访问和处理。它通常包含了数据模型、数据访问层和业务逻辑等。</li><li>View：视图层，负责展示数据并与用户进行交互。它通常包含了用户界面和用户交互逻辑等。</li><li>ViewModel：视图模型层，负责将模型层的数据转化为视图层可用的数据，并处理视图层的用户交互逻辑。它通常包含了数据绑定、命令绑定和业务逻辑等。</li></ul><h2 id="MVVM的优势"><a href="#MVVM的优势" class="headerlink" title="MVVM的优势"></a>MVVM的优势</h2><p>MVVM设计模式的优势在于它能够提高代码的可维护性、可测试性和可扩展性。</p><ul><li>可维护性：由于视图和模型之间的解耦，开发人员可以更容易地对视图和模型进行独立的修改和维护，而不会对其他部分产生影响。</li><li>可测试性：由于ViewModel负责处理业务逻辑，开发人员可以更容易地编写针对ViewModel的单元测试，而不需要依赖于具体的视图。</li><li>可扩展性：由于视图和模型之间的解耦，开发人员可以更容易地对视图和模型进行扩展，而不会对其他部分产生影响。</li></ul><h2 id="MVVM的实现方式"><a href="#MVVM的实现方式" class="headerlink" title="MVVM的实现方式"></a>MVVM的实现方式</h2><p>MVVM的实现方式有多种，下面以一个简单的示例来介绍其中一种实现方式。</p><h3 id="1-创建模型-Model"><a href="#1-创建模型-Model" class="headerlink" title="1. 创建模型(Model)"></a>1. 创建模型(Model)</h3><p>首先，我们需要创建一个模型类来表示我们的数据。比如，我们创建一个User模型类，用于表示用户的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建视图-View"><a href="#2-创建视图-View" class="headerlink" title="2. 创建视图(View)"></a>2. 创建视图(View)</h3><p>接下来，我们需要创建一个视图组件来展示用户的信息，并与用户进行交互。比如，我们创建一个UserView组件，用于展示用户的姓名和年龄，并提供一个按钮用于修改用户的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;update&quot;&gt;修改&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: this.user.name,</span><br><span class="line">      age: this.user.age</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update() &#123;</span><br><span class="line">      // 处理修改按钮的点击事件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-创建视图模型-ViewModel"><a href="#3-创建视图模型-ViewModel" class="headerlink" title="3. 创建视图模型(ViewModel)"></a>3. 创建视图模型(ViewModel)</h3><p>然后，我们需要创建一个视图模型类来将模型的数据转化为视图可用的数据，并处理视图的用户交互逻辑。比如，我们创建一个UserViewModel视图模型类，用于将User模型的数据转化为UserView组件可用的数据，并处理修改按钮的点击事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserViewModel</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">user</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span>.<span class="property">name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">user</span>.<span class="property">age</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span>.<span class="property">age</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理修改按钮的点击事件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-绑定视图-View-和视图模型-ViewModel"><a href="#4-绑定视图-View-和视图模型-ViewModel" class="headerlink" title="4. 绑定视图(View)和视图模型(ViewModel)"></a>4. 绑定视图(View)和视图模型(ViewModel)</h3><p>最后，我们需要在视图中绑定视图模型，以实现数据的双向绑定和用户交互的命令绑定。比如，我们可以在父组件中引入UserView组件，并将UserViewModel实例作为props传递给UserView组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;user-view :user=&quot;userViewModel&quot;&gt;&lt;/user-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import UserView from &#x27;./UserView.vue&#x27;;</span><br><span class="line">import User from &#x27;./User.js&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    UserView</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      userViewModel: new UserViewModel(new User(&#x27;John Doe&#x27;, 25))</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/image17.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVVM设计模式通过将视图(View)和模型(Model)之间的依赖关系解耦，提高了代码的可维护性、可测试性和可扩展性。通过创建视图模型(ViewModel)来处理数据的转化和用户交互逻辑，实现了视图(View)和模型(Model)之间的解耦。同时，通过数据绑定和命令绑定，实现了视图(View)和视图模型(ViewModel)之间的双向通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue中 main.js, APP.vue和 index.html 的作用和关系</title>
    <link href="http://blog.ioimp.top/2023/12/22/Vue%E4%B8%AD-main-js-APP-vue%E5%92%8C-index-html-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%85%B3%E7%B3%BB/"/>
    <id>http://blog.ioimp.top/2023/12/22/Vue%E4%B8%AD-main-js-APP-vue%E5%92%8C-index-html-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%85%B3%E7%B3%BB/</id>
    <published>2023-12-22T15:47:51.000Z</published>
    <updated>2024-03-04T02:26:48.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Vue中，main.js、APP.vue和index.html是三个核心文件，它们在Vue项目中扮演着不同的角色和功能。</p><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>index.html是Vue项目的入口文件。它是一个HTML文件，包含了整个应用的骨架。在index.html中，我们可以定义应用的标题、引入CSS和JavaScript文件，以及提供一个容器元素（通常是一个div元素），用于挂载Vue实例。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Vue App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>main.js是Vue应用的入口文件。它是一个JavaScript文件，用于创建和配置Vue实例。在main.js中，我们可以引入Vue库，创建Vue实例，并将其挂载到index.html中的容器元素上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先引入了Vue库和App.vue组件。然后，创建了一个Vue实例，并使用render函数渲染App组件。最后，使用$mount方法将Vue实例挂载到id为”app”的元素上。</p><h2 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h2><p>App.vue是Vue应用的根组件。它是一个单文件组件，包含了应用的整体布局和逻辑。在App.vue中，我们可以定义应用的顶级路由、导航栏、侧边栏等组件。同时，App.vue也可以包含其他子组件，用于构建整个应用的页面结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My Vue App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/* 样式定义 */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个顶级的div元素，包含了一个header元素和一个router-view元素。header元素用于显示应用的标题和导航栏，router-view元素用于渲染当前路由对应的组件。</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>这三个文件之间的关系如下：</p><ol><li>index.html是整个应用的入口文件，它引入了main.js和App.vue。</li><li>main.js是Vue应用的入口文件，它创建了Vue实例并将其挂载到index.html中的容器元素上。</li><li>App.vue是Vue应用的根组件，它包含了应用的整体布局和逻辑。在main.js中，我们使用import语句引入了App.vue，并在Vue实例的配置中使用了App组件。</li></ol><p>综上所述，index.html提供了应用的骨架，main.js创建了Vue实例并将其挂载到index.html中的容器元素上，而App.vue定义了整个应用的布局和逻辑。通过这三个文件的协作，我们可以构建出一个完整的Vue应用。<br><img src="/images/image16.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue基础" scheme="http://blog.ioimp.top/tags/Vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>为什么 yarn build 命令非常耗时</title>
    <link href="http://blog.ioimp.top/2023/12/22/%E4%B8%BA%E4%BB%80%E4%B9%88-yarn-build%E5%91%BD%E4%BB%A4%E9%9D%9E%E5%B8%B8%E8%80%97%E6%97%B6/"/>
    <id>http://blog.ioimp.top/2023/12/22/%E4%B8%BA%E4%BB%80%E4%B9%88-yarn-build%E5%91%BD%E4%BB%A4%E9%9D%9E%E5%B8%B8%E8%80%97%E6%97%B6/</id>
    <published>2023-12-22T08:31:23.000Z</published>
    <updated>2024-03-04T02:26:48.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开发过程中，我们经常使用构建工具来编译、打包和优化我们的代码。而在前端开发中，<code>yarn build</code> 命令是常用的构建命令之一。然而，你可能会注意到，<code>yarn build</code> 命令有时候会非常耗时，特别是在项目变得庞大复杂时。那么，为什么 <code>yarn build</code> 命令会如此耗时呢？本篇博客将对此进行探讨。</p><h2 id="1-代码量的增加"><a href="#1-代码量的增加" class="headerlink" title="1. 代码量的增加"></a>1. 代码量的增加</h2><p>随着项目的发展，代码量也会逐渐增加。更多的代码需要被编译、转换、打包和优化，这必然会增加构建的时间。尤其是在处理大量文件时，构建工具需要遍历每一个文件并进行处理，这将会消耗大量的时间。</p><h2 id="2-依赖项的增多"><a href="#2-依赖项的增多" class="headerlink" title="2. 依赖项的增多"></a>2. 依赖项的增多</h2><p>在现代的前端开发中，我们通常依赖于许多第三方库和工具。这些依赖项可能有自己的构建过程，当我们执行 <code>yarn build</code> 命令时，构建工具需要先编译和打包这些依赖项，然后再处理我们自己的代码。因此，依赖项的增多也会导致构建时间的增加。</p><h2 id="3-文件读取和加载"><a href="#3-文件读取和加载" class="headerlink" title="3. 文件读取和加载"></a>3. 文件读取和加载</h2><p>在构建过程中，构建工具需要从磁盘读取对应的文件到内存中进行处理。这个过程涉及到磁盘的读取速度和文件的大小。如果项目中有大量的文件或者文件很大，那么读取和加载的时间将会增加。</p><h2 id="4-代码处理和转换"><a href="#4-代码处理和转换" class="headerlink" title="4. 代码处理和转换"></a>4. 代码处理和转换</h2><p>一旦文件被加载到内存中，构建工具开始根据配置使用对应的 loader 对代码进行处理和转换。例如，对于 JavaScript 文件，可能会使用 Babel 进行转换；对于 CSS 文件，可能会使用 PostCSS 进行处理。这个处理和转换的过程可能会涉及到复杂的算法和逻辑，因此会耗费一定的时间。</p><h2 id="5-输出到磁盘"><a href="#5-输出到磁盘" class="headerlink" title="5. 输出到磁盘"></a>5. 输出到磁盘</h2><p>在代码处理和转换完成后，构建工具会将处理完的内容输出到磁盘的指定目录。这个过程也需要写入磁盘的速度和文件的大小。如果输出的文件很多或者文件很大，那么写入磁盘的时间将会增加。</p><h2 id="6-优化和压缩过程"><a href="#6-优化和压缩过程" class="headerlink" title="6. 优化和压缩过程"></a>6. 优化和压缩过程</h2><p>在构建过程中，我们通常会对代码进行优化和压缩，以提高性能和减少文件大小。这些优化和压缩过程可能需要较长的时间，特别是在处理大型项目时。例如，压缩和混淆 JavaScript 代码、优化 CSS 样式、压缩图片等都需要一定的时间。</p><h2 id="7-硬件性能限制"><a href="#7-硬件性能限制" class="headerlink" title="7. 硬件性能限制"></a>7. 硬件性能限制</h2><p>在一些较老或配置较低的计算机上，构建过程可能会更加耗时。较慢的处理器、较少的内存和较慢的硬盘都会对构建时间产生影响。因此，如果你的计算机性能较低，那么构建时间可能会更长。</p><h2 id="8-构建过程的优化"><a href="#8-构建过程的优化" class="headerlink" title="8. 构建过程的优化"></a>8. 构建过程的优化</h2><p>尽管 <code>yarn build</code> 命令可能会耗时，但我们仍然可以采取一些措施来优化构建过程，以减少构建时间。以下是一些常见的优化方法：</p><ul><li>使用增量构建：只重新构建修改过的文件，而不是整个项目。</li><li>使用缓存：将构建过程中生成的中间文件缓存起来，以便下次构建时能够复用。</li><li>并行处理：将构建过程中的任务并行执行，以提高整体的构建速度。</li><li>优化配置文件：检查构建工具的配置文件，确保其使用了最佳的配置选项。</li></ul><p>总结起来，<code>yarn build</code> 命令耗时的原因有很多，包括代码量的增加、依赖项的增多、文件读取和加载、代码处理和转换、输出到磁盘、优化和压缩过程、硬件性能限制等。然而，我们可以通过优化构建过程和硬件环境，来减少构建时间，提高开发效率。希望本篇博客能够对你理解 <code>yarn build</code> 命令的耗时问题有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
    <category term="WebPack" scheme="http://blog.ioimp.top/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>WebPack对Js降级实现兼容低版本浏览器</title>
    <link href="http://blog.ioimp.top/2023/12/22/WebPack%E5%AF%B9js%E9%99%8D%E7%BA%A7%E5%AE%9E%E7%8E%B0%E5%85%BC%E5%AE%B9%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://blog.ioimp.top/2023/12/22/WebPack%E5%AF%B9js%E9%99%8D%E7%BA%A7%E5%AE%9E%E7%8E%B0%E5%85%BC%E5%AE%B9%E4%BD%8E%E7%89%88%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2023-12-22T07:34:51.000Z</published>
    <updated>2024-03-04T02:26:48.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前端开发中，我们经常会遇到兼容性的问题，特别是在低版本浏览器中。为了解决这个问题，Webpack提供了一种降级的方式，可以实现在低版本浏览器中兼容新的JavaScript语法和功能。</p><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p>Webpack是一个现代化的前端构建工具，它能够将多个JavaScript文件打包成一个或多个bundle文件，从而提高网站性能和加载速度。除此之外，Webpack还提供了许多其他功能，如代码分割、模块化、热模块替换等。</p><h2 id="为什么需要兼容低版本浏览器"><a href="#为什么需要兼容低版本浏览器" class="headerlink" title="为什么需要兼容低版本浏览器"></a>为什么需要兼容低版本浏览器</h2><p>虽然现代浏览器已经支持了许多新的JavaScript语法和功能，但是在实际开发中我们仍然需要兼容低版本浏览器。因为在某些情况下，用户可能仍然使用低版本的浏览器，我们不能因为他们的浏览器版本低就让他们无法正常使用我们的网站或应用。</p><h2 id="Webpack如何实现兼容低版本浏览器"><a href="#Webpack如何实现兼容低版本浏览器" class="headerlink" title="Webpack如何实现兼容低版本浏览器"></a>Webpack如何实现兼容低版本浏览器</h2><p>Webpack提供了一些插件和配置选项，可以帮助我们实现兼容低版本浏览器。下面是一些常用的方法：</p><h3 id="Babel插件"><a href="#Babel插件" class="headerlink" title="Babel插件"></a>Babel插件</h3><p>Babel是一个广泛使用的JavaScript编译器，它可以将新的JavaScript语法转换成低版本浏览器可以理解的语法。在Webpack中，我们可以使用Babel插件来处理JavaScript文件。</p><p>首先，我们需要安装一些必要的Babel插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env --save-dev</span><br></pre></td></tr></table></figure><p>然后，在Webpack配置文件中，我们需要添加一个规则来处理JavaScript文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Webpack就会使用Babel插件来转换JavaScript文件，并将其输出到bundle文件中。</p><h3 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h3><p>除了转换新的JavaScript语法外，我们还需要处理一些新的JavaScript功能，比如Promise、Map、Set等。为了在低版本浏览器中使用这些功能，我们可以使用Polyfill。</p><p>Polyfill是一种JavaScript代码片段，它可以在低版本浏览器中实现新的JavaScript功能。在Webpack中，我们可以使用<code>@babel/polyfill</code>插件来引入Polyfill。</p><p>首先，我们需要安装<code>@babel/polyfill</code>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/polyfill --save</span><br></pre></td></tr></table></figure><p>然后，在入口文件中，我们需要引入Polyfill：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@babel/polyfill&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样，Webpack会将Polyfill打包到bundle文件中，并在低版本浏览器中自动加载。</p><h3 id="其他配置选项"><a href="#其他配置选项" class="headerlink" title="其他配置选项"></a>其他配置选项</h3><p>除了Babel插件和Polyfill外，Webpack还提供了其他一些配置选项，可以帮助我们实现兼容低版本浏览器。比如，我们可以使用<code>target</code>选项来指定要兼容的浏览器版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">target</span>: [<span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;browserslist:ie &gt;= 8&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这样，Webpack会根据我们的配置自动处理兼容性问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们介绍了Webpack如何实现兼容低版本浏览器的方法。通过使用Babel插件、Polyfill和其他配置选项，我们可以让我们的网站或应用在低版本浏览器中正常运行。希望本文对你有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
    <category term="WebPack" scheme="http://blog.ioimp.top/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack中加载器模式设为asset，为什么以8KB大小区分图片</title>
    <link href="http://blog.ioimp.top/2023/12/22/Webpack%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%BE%E4%B8%BAasset%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A58KB%E5%A4%A7%E5%B0%8F%E5%8C%BA%E5%88%86%E5%9B%BE%E7%89%87/"/>
    <id>http://blog.ioimp.top/2023/12/22/Webpack%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AE%BE%E4%B8%BAasset%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A58KB%E5%A4%A7%E5%B0%8F%E5%8C%BA%E5%88%86%E5%9B%BE%E7%89%87/</id>
    <published>2023-12-22T07:11:39.000Z</published>
    <updated>2024-03-04T02:26:48.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Webpack中加载器模式设为asset，为什么以8KB大小区分图片"><a href="#Webpack中加载器模式设为asset，为什么以8KB大小区分图片" class="headerlink" title="Webpack中加载器模式设为asset，为什么以8KB大小区分图片"></a>Webpack中加载器模式设为asset，为什么以8KB大小区分图片</h2><p>在Webpack中，加载器模式可以设置为<code>asset</code>，用于处理资源文件（例如图片、字体等）。</p><p>默认情况下，Webpack会根据资源文件的大小来决定如何处理。当资源文件的大小小于8KB时，Webpack会将其转换为Data URL（base64编码）并直接嵌入到生成的JS文件中，以减少HTTP请求。而当资源文件的大小大于等于8KB时，Webpack会将其处理为独立的文件，并通过URL引用的方式加载。</p><p>这种区分是为了平衡代码体积和加载性能之间的关系。将小文件转换为Data URL可以减少HTTP请求的数量，但会增加JS文件的体积，可能导致加载时间变长。而将大文件作为独立文件加载可以减小JS文件的体积，但会增加HTTP请求的数量，可能导致加载时间变长。</p><p>因此，8KB是一个经验值，可以根据具体项目的需求进行调整。如果项目中有大量的小文件，可以考虑将此值调低，以减少HTTP请求的数量；如果项目中有大量的大文件，可以考虑将此值调高，以减小JS文件的体积。</p><h2 id="将图片转换为base64编码的好处和坏处如下："><a href="#将图片转换为base64编码的好处和坏处如下：" class="headerlink" title="将图片转换为base64编码的好处和坏处如下："></a>将图片转换为base64编码的好处和坏处如下：</h2><p><strong>好处：</strong></p><ol><li>减少HTTP请求：将图片转换为base64编码后，可以直接嵌入到HTML、CSS或JavaScript文件中，避免了额外的HTTP请求，从而加快页面加载速度。</li><li>简化项目结构：将图片嵌入到代码中，可以减少项目中的文件数量，简化项目结构，方便管理和部署。</li><li>提高图片加载速度：由于base64编码的图片嵌入到文件中，不需要再进行额外的网络请求，因此可以减少图片的加载时间。</li></ol><p><strong>坏处：</strong></p><ol><li>增加文件体积：base64编码会使图片的体积增加约1&#x2F;3，因为编码后的文本比原始二进制数据要大。这可能导致文件体积增大，特别是当有多个图片被转换为base64编码时，会增加整个文件的大小。</li><li>缓存问题：base64编码的图片无法被浏览器缓存，因为它们被嵌入到了文件中。每次文件更新都会导致图片重新下载，这可能会影响网页的性能。</li><li>不适用于大型图片：由于base64编码会增加文件体积，因此对于大型图片（通常超过几十KB或更大）来说，将其转换为base64编码可能导致文件过大，影响页面加载速度。</li></ol><p>因此，将图片转换为base64编码适用于小型图标或小图片，并且在需要减少HTTP请求和简化项目结构的情况下使用。对于大型图片，最好将其作为独立文件加载，以避免文件过大和缓存问题。</p><h2 id="WebPack如何处理字体图标"><a href="#WebPack如何处理字体图标" class="headerlink" title="WebPack如何处理字体图标"></a>WebPack如何处理字体图标</h2><p><img src="/images/image15.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
    <category term="WebPack" scheme="http://blog.ioimp.top/tags/WebPack/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务的区别</title>
    <link href="http://blog.ioimp.top/2023/12/22/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ioimp.top/2023/12/22/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-12-21T16:52:10.000Z</published>
    <updated>2024-03-04T02:26:48.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>宏任务是由浏览器引擎进行调度和执行的，它们会被放入宏任务队列中，并且按照队列的顺序执行。宏任务的执行时间较长，因此会造成较大的延迟。常见的宏任务包括DOM事件处理、setTimeout和setInterval等。</p><p>微任务是在宏任务执行完毕之后立即执行的任务，它们会被放入微任务队列中，并且在宏任务队列为空时执行。微任务的执行时间较短，因此不会造成较大的延迟。常见的微任务包括Promise的resolve和reject回调、MutationObserver和process.nextTick等。</p><p>由于微任务会在宏任务执行完毕之后立即执行，因此微任务的优先级较高。也就是说，当一个宏任务执行完毕后，会立即执行所有的微任务，而不会等待下一个宏任务。这样可以保证微任务的执行顺序不会被打乱。</p><p>总结起来，宏任务的执行顺序是先进先出，而微任务的执行顺序是后进先出。宏任务的执行时间较长，会造成较大的延迟，而微任务的执行时间较短，不会造成较大的延迟。微任务的优先级较高，会在宏任务执行完毕之后立即执行。<br><img src="/images/image13.png"><br><img src="/images/image14.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么说同步任务是非耗时任务，异步任务是耗时任务</title>
    <link href="http://blog.ioimp.top/2023/12/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%98%AF%E9%9D%9E%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%98%AF%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>http://blog.ioimp.top/2023/12/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%98%AF%E9%9D%9E%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%98%AF%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1/</id>
    <published>2023-12-21T16:35:58.000Z</published>
    <updated>2024-03-04T02:26:48.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>同步任务</strong>是指在程序执行过程中，必须等待该任务完成后才能继续执行下面的代码。因为同步任务会阻塞程序的执行，所以它通常被认为是非耗时任务。</p><p><strong>异步任务</strong>是指在程序执行过程中，不需要等待该任务完成就可以继续执行下面的代码。异步任务通常会通过多线程、回调函数或者事件驱动等方式实现。由于异步任务不会阻塞程序的执行，所以它通常被认为是耗时任务。</p><p><strong>需要注意的是</strong>，同步任务和异步任务的耗时性质与任务本身的执行时间没有直接关系。一个同步任务可能执行时间很长，但它会阻塞程序的执行，所以被认为是非耗时任务。而一个异步任务可能执行时间很短，但它不会阻塞程序的执行，所以被认为是耗时任务。</p><p>耗时和非耗时的区分是<strong>相对于程序整体执行流程而言的</strong>。耗时任务通常指的是那些需要较长时间才能完成的任务，比如访问网络、读写大文件、进行复杂计算等。这些任务如果以同步方式执行，会导致程序在等待任务完成期间无法进行任何其他操作，即阻塞了程序的执行流程，用户体验较差。</p><p>非耗时任务则是那些可以迅速完成的任务，如简单的数学计算、修改变量值等。这些任务即使以同步方式执行，也不会对程序的流畅性造成太大影响。</p><p>因此，在编程中，通常会将耗时任务设计为异步执行，以避免阻塞主线程，提高程序的响应性和效率。通过回调函数、Promise、async&#x2F;await等机制，可以在耗时任务完成后再执行相关的操作，而不必让整个程序等待耗时任务的完成。这就是为什么通常将同步任务视为非耗时任务，而将异步任务视为耗时任务的原因。</p><h2 id="同步任务和异步任务的执行过程"><a href="#同步任务和异步任务的执行过程" class="headerlink" title="同步任务和异步任务的执行过程"></a>同步任务和异步任务的执行过程</h2><p><img src="/images/image12.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
    <category term="异步操作" scheme="http://blog.ioimp.top/tags/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Node中async/await的详解</title>
    <link href="http://blog.ioimp.top/2023/12/22/Node%E4%B8%ADasync-await%E7%9A%84%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.ioimp.top/2023/12/22/Node%E4%B8%ADasync-await%E7%9A%84%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-12-21T16:23:35.000Z</published>
    <updated>2024-03-04T02:26:48.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="async-await的基本使用"><a href="#async-await的基本使用" class="headerlink" title="async&#x2F;await的基本使用"></a>async&#x2F;await的基本使用</h1><p>async&#x2F;await是ES8中引入的新语法，用于简化promise的异步操作。</p><p>使用async关键字修饰函数，表示该函数是一个异步函数。异步函数内部可以使用await关键字来等待一个promise对象的执行结果。</p><p>await关键字可以放在任何返回promise的表达式前面，它会暂停函数的执行，直到promise被解析或拒绝。如果promise被解析，await表达式会返回解析的值；如果promise被拒绝，await表达式会抛出一个错误。</p><p>异步函数可以像普通函数一样返回一个值，返回的值会被包装成一个被解析的promise对象。</p><p>以下是示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步函数示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 使用await等待promise的执行结果</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个被解析的promise对象</span></span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">json</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用异步函数示例</span></span><br><span class="line"><span class="title function_">fetchData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>fetchData</code>是一个异步函数，使用<code>await</code>关键字等待<code>fetch</code>函数返回的promise对象的执行结果。在<code>fetchData</code>函数内部，可以像同步代码一样使用<code>result</code>变量来访问<code>fetch</code>函数返回的结果。</p><p>调用异步函数时，可以像调用普通函数一样使用<code>.then</code>和<code>.catch</code>方法来处理异步操作的结果。在上面的示例中，使用<code>.then</code>方法来处理异步操作的成功结果，使用<code>.catch</code>方法来处理异步操作的错误结果。</p><p>通过使用async&#x2F;await，我们可以将异步操作的代码写得更加简洁、易读，并且可以避免使用链式调用then的方式。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="1-使用环境"><a href="#1-使用环境" class="headerlink" title="1. 使用环境"></a>1. 使用环境</h2><ul><li><code>async</code>和<code>await</code>是ES7的新特性，需要确保Node版本至少为7.6.0或更高。</li><li><code>async</code>函数返回一个Promise对象，可以使用<code>.then()</code>和<code>.catch()</code>进行链式调用。</li></ul><h2 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h2><ul><li>使用<code>await</code>时，如果Promise被拒绝（reject），会抛出异常。因此需要使用<code>try...catch</code>语句进行错误处理。</li><li>如果没有正确处理错误，可能会导致程序崩溃。</li></ul><h2 id="3-循环中使用"><a href="#3-循环中使用" class="headerlink" title="3. 循环中使用"></a>3. 循环中使用</h2><ul><li>在循环中使用<code>await</code>时，需要注意可能会导致代码变成串行执行，影响性能。</li><li>如果需要并行执行，可以使用<code>Promise.all()</code>。</li></ul><h2 id="4-await的使用"><a href="#4-await的使用" class="headerlink" title="4. await的使用"></a>4. <code>await</code>的使用</h2><ul><li><code>await</code>只能在<code>async</code>函数内部使用。</li><li><code>await</code>后面跟着的应该是一个Promise对象或者任何要等待的值。</li><li>在async修饰的方法中，第一个await之前的代码都是同步执行的，而第一个await之后的代码都会异步执行。</li></ul><h2 id="5-返回值"><a href="#5-返回值" class="headerlink" title="5. 返回值"></a>5. 返回值</h2><ul><li><code>async</code>函数总是返回一个Promise，即使函数内部没有使用<code>await</code>。</li><li>如果<code>async</code>函数内部抛出错误，返回的Promise会被拒绝（reject）。</li></ul><h2 id="6-await的等待"><a href="#6-await的等待" class="headerlink" title="6. await的等待"></a>6. <code>await</code>的等待</h2><ul><li><code>await</code>会暂停其后的代码执行，直到Promise解决（resolve）或拒绝（reject）。</li></ul><h2 id="7-调试"><a href="#7-调试" class="headerlink" title="7. 调试"></a>7. 调试</h2><ul><li>在使用<code>async</code>和<code>await</code>时，可能会使得调试变得更加困难，因为它们会改变错误堆栈的追踪方式。</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
    <category term="异步操作" scheme="http://blog.ioimp.top/tags/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Node中Promise 对象的意思</title>
    <link href="http://blog.ioimp.top/2023/12/21/Node%E4%B8%ADPromise-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <id>http://blog.ioimp.top/2023/12/21/Node%E4%B8%ADPromise-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E6%80%9D/</id>
    <published>2023-12-21T02:56:30.000Z</published>
    <updated>2024-03-04T02:26:48.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node中Promise-对象的意思"><a href="#Node中Promise-对象的意思" class="headerlink" title="Node中Promise 对象的意思"></a>Node中Promise 对象的意思</h1><p>Promise 对象是 JavaScript 中处理异步操作的一种方式，它代表了一个异步操作的最终完成或失败，并可以返回一个结果或错误。</p><h2 id="Promise-的基本概念"><a href="#Promise-的基本概念" class="headerlink" title="Promise 的基本概念"></a>Promise 的基本概念</h2><ul><li>Promise 是一个构造函数<ul><li>我们可以创建Promise的实例 const p&#x3D; new Promise()</li><li>new 出来的一个实例对象，代表一个异步操作</li></ul></li><li>Promise.prototype上包含then() </li><li>.then（）方法用来预先指定成功和失败的回调函数<ul><li>p.then(成功回调函数，失败的回调函数)</li><li>p.then(result&#x3D;&gt;{},error&#x3D;&gt;{})</li></ul></li></ul><h2 id="Promise-对象有三种状态："><a href="#Promise-对象有三种状态：" class="headerlink" title="Promise 对象有三种状态："></a>Promise 对象有三种状态：</h2><ol><li>Pending（进行中）：初始状态，表示异步操作还在进行中，既不是成功也不是失败状态。</li><li>Fulfilled（已完成）：表示异步操作成功完成，并返回了一个结果。</li><li>Rejected（已失败）：表示异步操作失败，并返回了一个错误。</li></ol><p>Promise 对象的构造函数接受一个执行器函数作为参数，这个执行器函数有两个参数，分别是 resolve 和 reject 函数。在执行器函数中，我们可以执行异步操作，并在适当的时候调用 resolve 或 reject 函数来改变 Promise 对象的状态。</p><h2 id="Promise-对象具有以下特点："><a href="#Promise-对象具有以下特点：" class="headerlink" title="Promise 对象具有以下特点："></a>Promise 对象具有以下特点：</h2><ol><li>Promise 对象是不可变的，一旦状态改变就无法再次改变。</li><li>Promise 对象可以通过 <code>.then()</code> 方法添加成功状态的回调函数，通过 <code>.catch()</code> 方法添加失败状态的回调函数，也可以使用 <code>.finally()</code> 方法添加无论成功或失败都会执行的回调函数。</li><li>Promise 对象可以通过 Promise 链实现对多个异步操作的串行或并行处理。</li><li>Promise 对象可以通过 <code>async/await</code> 语法进行更简洁的异步操作处理。</li></ol><h2 id="可以用console-dir-Promise-来查课Promise对象的属性"><a href="#可以用console-dir-Promise-来查课Promise对象的属性" class="headerlink" title="可以用console.dir(Promise) 来查课Promise对象的属性"></a>可以用console.dir(Promise) 来查课Promise对象的属性</h2><p>使用 Promise 对象可以更好地处理异步操作，避免了回调地狱和层层嵌套的问题，使代码更加清晰和可维护。<br><code>console.dir</code> 是 JavaScript 中的一个方法，用于将一个对象的所有可枚举属性打印到控制台中，以便查看对象的结构和属性。</p><p>该方法接受一个对象作为参数，并将对象的属性以键值对的形式打印到控制台中。与 <code>console.log()</code> 方法不同，<code>console.dir()</code> 方法会显示对象的属性的详细信息，包括属性名称、属性值和属性的数据类型。</p><p><code>console.dir()</code> 方法在调试和开发过程中非常有用，可以帮助开发人员了解对象的结构和属性，以便更好地理解和调试代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 利用node  fs模块进行的读取文件操作 三次嵌套容易引起回调地狱</span></span><br><span class="line"><span class="comment">// const &#123; error &#125; = require(&#x27;console&#x27;);</span></span><br><span class="line"><span class="comment">// let fs = require(&#x27;fs&#x27;);</span></span><br><span class="line"><span class="comment">// fs.readFile(&#x27;./file/test1.txt&#x27;,&#x27;utf-8&#x27;,(error,res)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     if(error) console.log(error.message)</span></span><br><span class="line"><span class="comment">//     console.log(res)</span></span><br><span class="line"><span class="comment">//     fs.readFile(&#x27;./file/test2.txt&#x27;,&#x27;utf-8&#x27;,(error,res)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//         if(error) console.log(error.message)</span></span><br><span class="line"><span class="comment">//         console.log(res)</span></span><br><span class="line"><span class="comment">//         fs.readFile(&#x27;./file/test3.txt&#x27;,&#x27;utf-8&#x27;,(error,res)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//             if(error) console.log(error.message)</span></span><br><span class="line"><span class="comment">//             console.log(res)</span></span><br><span class="line"><span class="comment">//         &#125;)</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用then-fs来进行文件读取操作（未进行顺序处理）</span></span><br><span class="line"><span class="comment">// import thenFs from &#x27;then-fs&#x27;</span></span><br><span class="line"><span class="comment">// thenFs.readFile(&#x27;./file/test.txt&#x27;,&#x27;utf8&#x27;).then((r1)=&gt;&#123;console.log(r1)&#125;)</span></span><br><span class="line"><span class="comment">// thenFs.readFile(&#x27;./file/test2.txt&#x27;,&#x27;utf8&#x27;).then((r2)=&gt;&#123;console.log(r2)&#125;)</span></span><br><span class="line"><span class="comment">// thenFs.readFile(&#x27;./file/test3.txt&#x27;,&#x27;utf8&#x27;).then((r3)=&gt;&#123;console.log(r3)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// then-fs顺序处理</span></span><br><span class="line"><span class="keyword">import</span> thenFs <span class="keyword">from</span> <span class="string">&#x27;then-fs&#x27;</span></span><br><span class="line">thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./file/test.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r1</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">    <span class="keyword">return</span> thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./file/test2.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r2</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">        thenFs.<span class="title function_">readFile</span>(<span class="string">&#x27;./file/test3.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">r3</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>npm和pnpm的区别</title>
    <link href="http://blog.ioimp.top/2023/12/21/npm%E5%92%8Cpnpm%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ioimp.top/2023/12/21/npm%E5%92%8Cpnpm%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-12-21T01:43:41.000Z</published>
    <updated>2024-03-04T02:26:48.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>pnpm 和 npm 都是 JavaScript 包管理工具，用于安装和管理项目的依赖。</p><ol><li><p>安装速度：pnpm 在安装依赖时使用了硬链接的方式，可以复用已安装的依赖，因此安装速度更快。而 npm 则会将依赖完全复制到项目的 <code>node_modules</code> 目录中，因此安装速度相对较慢。</p></li><li><p>磁盘空间占用：由于 pnpm 使用了硬链接的方式，相同的依赖只会在磁盘上占用一份空间，因此 pnpm 的磁盘空间占用相对较小。而 npm 则会将每个项目的依赖都完整地复制到项目的 <code>node_modules</code> 目录中，因此磁盘空间占用较大。</p></li><li><p>内存占用：pnpm 在安装和运行时只需要占用较少的内存，因为它使用了硬链接和符号链接来共享依赖。而 npm 则需要占用较多的内存，因为它会将所有的依赖都解压到内存中。</p></li><li><p>兼容性：由于 pnpm 使用了硬链接和符号链接的方式，可能在某些操作系统或文件系统上不兼容。而 npm 则是使用了标准的文件复制方式，因此更加兼容。</p></li></ol><p>综上所述，pnpm 相对于 npm 来说，在安装速度、磁盘空间占用和内存占用方面有一定的优势，但在兼容性方面可能存在一些问题。因此，在选择使用哪个工具时，可以根据具体的项目需求和环境来决定。</p><p>pnpm 在安装依赖时会将依赖信息添加到项目的 package.json 文件中。这与 npm 的行为是一致的。当你使用 pnpm 安装依赖时，会自动更新 package.json 文件的 dependencies 或 devDependencies 字段，将安装的依赖添加到其中，以便项目在其他环境中能够正确地安装和运行所需的依赖。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端" scheme="http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES6" scheme="http://blog.ioimp.top/tags/ES6/"/>
    
    <category term="前端学习" scheme="http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node.js" scheme="http://blog.ioimp.top/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Scarpy_分布式爬虫</title>
    <link href="http://blog.ioimp.top/2023/12/03/Scarpy-%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB/"/>
    <id>http://blog.ioimp.top/2023/12/03/Scarpy-%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB/</id>
    <published>2023-12-03T03:59:26.000Z</published>
    <updated>2024-03-04T02:26:48.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式爬虫"><a href="#分布式爬虫" class="headerlink" title="分布式爬虫"></a>分布式爬虫</h1><h2 id="一-增量式爬虫"><a href="#一-增量式爬虫" class="headerlink" title="一. 增量式爬虫"></a>一. 增量式爬虫</h2><p>​增量式爬虫, 顾名思义. 可以对网站进行反复抓取. 然后发现新东西了就保存起来. 遇到了以前抓取过的内容就自动过滤掉即可. 其核心思想就两个字. 去重. 并且可以反复去重. 今天运行一下. 明天再运行一下. 将不同的数据过滤出来. 相同的数据去除掉(不保存)即可. </p><p>​此时, 我们以天涯为目标来尝试一下完成增量式爬虫. </p><p>spider: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> tianya.items <span class="keyword">import</span> TianyaItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TySpider</span>(scrapy.Spider):</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&#x27;ty&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;tianya.cn&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://bbs.tianya.cn/list-worldlook-1.shtml&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        self.red = Redis(password=<span class="string">&quot;123456&quot;</span>, db=<span class="number">6</span>, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, resp, **kwargs</span>):</span><br><span class="line">        tbodys = resp.css(<span class="string">&quot;.tab-bbs-list tbody&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> tbody <span class="keyword">in</span> tbodys:</span><br><span class="line">            hrefs = tbody.xpath(<span class="string">&quot;./tr/td[1]/a/@href&quot;</span>).extract()</span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> hrefs:</span><br><span class="line">                <span class="comment"># 两个方案.</span></span><br><span class="line">                url = resp.urljoin(h)</span><br><span class="line">                <span class="comment"># 判断是否在该set集合中有数据</span></span><br><span class="line">                r = self.red.sismember(<span class="string">&quot;tianya:details&quot;</span>, url)  </span><br><span class="line">                <span class="comment">#   1. url去重. 优点: 简单, 缺点: 如果有人回复了帖子.就无法提取到最新的数据了</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                    <span class="keyword">yield</span> scrapy.Request(url=resp.urljoin(h), callback=self.parse_details)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;该url已经被抓取过<span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        next_href = resp.xpath(<span class="string">&quot;//div[@class=&#x27;short-pages-2 clearfix&#x27;]/div[@class=&#x27;links&#x27;]/a[last()]/@href&quot;</span>).extract_first()</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=resp.urljoin(next_href), callback=self.parse)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_details</span>(<span class="params">self, resp, **kwargs</span>):</span><br><span class="line">        title = resp.xpath(<span class="string">&#x27;//*[@id=&quot;post_head&quot;]/h1/span[1]/span/text()&#x27;</span>).extract_first()</span><br><span class="line">        content = resp.xpath(<span class="string">&#x27;//*[@id=&quot;bd&quot;]/div[4]/div[1]/div/div[2]/div[1]/text()&#x27;</span>).extract_first()</span><br><span class="line">        item = TianyaItem()</span><br><span class="line">        item[<span class="string">&#x27;title&#x27;</span>] = title</span><br><span class="line">        item[<span class="string">&#x27;content&#x27;</span>] = content</span><br><span class="line">        <span class="comment"># 提取完数据. 该url进入redis</span></span><br><span class="line">        self.red.sadd(<span class="string">&quot;tianya:details&quot;</span>, resp.url)  </span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​pipelines</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don&#x27;t forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful for handling different item types with a single interface</span></span><br><span class="line"><span class="keyword">from</span> itemadapter <span class="keyword">import</span> ItemAdapter</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TianyaPipeline</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        <span class="comment">#   2. 数据内容去重. 优点: 保证数据的一致性. 缺点: 需要每次都把数据从网页中提取出来</span></span><br><span class="line">        <span class="built_in">print</span>(json.dumps(<span class="built_in">dict</span>(item)))</span><br><span class="line">        r = self.red.sadd(<span class="string">&quot;tianya:pipelines:items&quot;</span>, json.dumps(<span class="built_in">dict</span>(item)))</span><br><span class="line">        <span class="keyword">if</span> r:</span><br><span class="line">            <span class="comment"># 进入数据库</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;存入数据库&quot;</span>, item[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已经在数据里了&quot;</span>, item[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.red = Redis(password=<span class="string">&quot;123456&quot;</span>, db=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.red.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方案是直接用redis进行的去重. 我们还可以选择使用数据库, mongodb进行过滤. 原理都一样, 不在赘述. </p><h2 id="二-分布式爬虫"><a href="#二-分布式爬虫" class="headerlink" title="二. 分布式爬虫"></a>二. 分布式爬虫</h2><p>​分布式爬虫, 就是搭建一个分布式的集群, 让其对一组资源进行分布联合爬取. </p><p>​既然要集群来抓取. 意味着会有好几个爬虫同时运行. 那此时就非常容易产生这样一个问题. 如果有重复的url怎么办?  在原来的程序中. scrapy中会由调度器来自动完成这个任务. 但是, 此时是多个爬虫一起跑. 而我们又知道不同的机器之间是不能直接共享调度器的. 怎么办? 我们可以采用redis来作为各个爬虫的调度器. 此时我们引出一个新的模块叫scrapy-redis. 在该模块中提供了这样一组操作. 它们重写了scrapy中的调度器. 并将调度队列和去除重复的逻辑全部引入到了redis中. 这样就形成了这样一组结构</p><p><img src="/images/scrapy02/image-20210812152215427.png" alt="image-20210812152215427"></p><p>​整体工作流程:</p><pre><code>1. 某个爬虫从redis_key获取到起始url. 传递给引擎, 到调度器. 然后把起始url直接丢到redis的请求队列里. 开始了scrapy的爬虫抓取工作.  2. 如果抓取过程中产生了新的请求. 不论是哪个节点产生的, 最终都会到redis的去重集合中进行判定是否抓取过. 3. 如果抓取过. 直接就放弃该请求. 如果没有抓取过. 自动丢到redis请求队列中. 4. 调度器继续从redis请求队列里获取要进行抓取的请求. 完成爬虫后续的工作. </code></pre><p>接下来. 我们用scrapy-redis完成上述流程</p><ol><li><p>首先, 创建项目, 和以前一样, 该怎么创建还怎么创建. </p></li><li><p>修改Spider. 将start_urls注释掉. 更换成redis_key</p></li><li><p>然后再settings中对redis以及scrapy_redis配置一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">REDIS_HOST = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">REDIS_PORT = <span class="number">6379</span></span><br><span class="line">REDIS_DB = <span class="number">8</span></span><br><span class="line">REDIS_PARAMS = &#123;</span><br><span class="line">    <span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># scrapy-redis配置信息  # 固定的</span></span><br><span class="line">SCHEDULER = <span class="string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span>  <span class="comment"># 如果为真. 在关闭时自动保存请求信息, 如果为假, 则不保存请求信息</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span> <span class="comment"># 去重的逻辑. 要用redis的</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">&#x27;tianya2.pipelines.Tianya2Pipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>: <span class="number">301</span>  <span class="comment"># 配置redis的pipeline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>布隆过滤器:</p><p>​平时, 我们如果需要对数据进行去重操作可以有以下方案: </p><pre><code>1. 直接用set集合来存储url. (最low的方案)2. 用set集合存储hash过的url. scrapy默认3. 用redis来存储hash过的请求, scrapy-redis默认就是这样做的. 如果请求非常非常多. redis压力是很大的.4. 用布隆过滤器. </code></pre><p>布隆过滤器的原理: 其实它里面就是一个改良版的bitmap. 何为bitmap, 假设我提前准备好一个数组, 然后把源数据经过hash计算. 会计算出一个数字. 我们按照下标来找到该下标对应的位置. 然后设置成1. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 李嘉诚</span><br><span class="line">b = 张翠山</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>]  <span class="number">10</span>个长度数组</span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span>(a) = <span class="number">3</span></span><br><span class="line"><span class="built_in">hash</span>(b) = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>] </span><br><span class="line"><span class="built_in">hash</span>(张三) = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找的时候依然执行该hash算法. 然后直接去找对应下标的位置看看是不是1. 是1就有, 不是1就没有</span></span><br></pre></td></tr></table></figure><p>这样有个不好的现象. 容易误判. 如果hash算法选的不够好. 很容易搞错. 那怎么办. 多选几个hash算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = 李嘉诚</span><br><span class="line">b = 张翠山</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">hash1(a) = <span class="number">3</span></span><br><span class="line">hash2(a) = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">hash1(b) = <span class="number">2</span></span><br><span class="line">hash2(b) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>],[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找的时候, 重新按照这个hash的顺序, 在重新执行一遍. 依然会得到2个值. 分别去这两个位置看是否是1. 如果全是1, 就有,  如果有一个是0, 就没有. </span></span><br></pre></td></tr></table></figure><p>在scrapy-redis中想要使用布隆过滤器是非常简单的. 你可以自己去写这个布隆过滤器的逻辑. 不过我建议直接用第三方的就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装布隆过滤器</span></span><br><span class="line">pip install scrapy_redis_bloomfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重类，要使用 BloomFilter 请替换 DUPEFILTER_CLASS</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&quot;scrapy_redis_bloomfilter.dupefilter.RFPDupeFilter&quot;</span></span><br><span class="line"><span class="comment"># 哈希函数的个数，默认为 6，可以自行修改</span></span><br><span class="line">BLOOMFILTER_HASH_NUMBER = <span class="number">6</span></span><br><span class="line"><span class="comment"># BloomFilter 的 bit 参数，默认 30，占用 128MB 空间，去重量级 1 亿</span></span><br><span class="line">BLOOMFILTER_BIT = <span class="number">30</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫开发" scheme="http://blog.ioimp.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Scrapy爬虫" scheme="http://blog.ioimp.top/tags/Scrapy%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>crawlSpider</title>
    <link href="http://blog.ioimp.top/2023/12/03/crawlSpider/"/>
    <id>http://blog.ioimp.top/2023/12/03/crawlSpider/</id>
    <published>2023-12-03T03:58:31.000Z</published>
    <updated>2024-03-04T02:26:48.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Scrapy抓取全网站数据"><a href="#Scrapy抓取全网站数据" class="headerlink" title="Scrapy抓取全网站数据"></a>Scrapy抓取全网站数据</h1><h2 id="一-使用常规Spider"><a href="#一-使用常规Spider" class="headerlink" title="一. 使用常规Spider"></a>一. 使用常规Spider</h2><p>我们把目光对准汽车之家. 抓取二手车信息.</p><p>注意, 汽车之家的访问频率要控制一下. 要不然会跳验证的. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOAD_DELAY = <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErshouSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;ershou&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;che168.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.che168.com/beijing/a0_0msdgscncgpi1ltocsp100exx0/?pvareaid=102179#currengpostion&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, resp, **kwargs</span>):</span><br><span class="line">        <span class="comment"># print(resp.text)</span></span><br><span class="line">        <span class="comment"># 链接提取器</span></span><br><span class="line">        le = LinkExtractor(restrict_xpaths=(<span class="string">&quot;//ul[@class=&#x27;viewlist_ul&#x27;]/li/a&quot;</span>,), deny_domains=(<span class="string">&quot;topicm.che168.com&quot;</span>,) )</span><br><span class="line">        links = le.extract_links(resp)</span><br><span class="line">        <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(</span><br><span class="line">                url=link.url,</span><br><span class="line">                callback=self.parse_detail</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># 翻页功能</span></span><br><span class="line">        le2 = LinkExtractor(restrict_xpaths=(<span class="string">&quot;//div[@id=&#x27;listpagination&#x27;]/a&quot;</span>,))</span><br><span class="line">        pages = le2.extract_links(resp)</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> pages:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=page.url, callback=self.parse_detail)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_detail</span>(<span class="params">self, resp, **kwargs</span>):</span><br><span class="line">        title = resp.xpath(<span class="string">&#x27;/html/body/div[5]/div[2]/h3/text()&#x27;</span>).extract_first()</span><br><span class="line">        <span class="built_in">print</span>(title)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LinkExtractor: 链接提取器. 可以非常方便的帮助我们从一个响应页面中提取到url链接. 我们只需要提前定义好规则即可. </p><p>参数: </p><p>​allow, 接收一堆正则表达式, 可以提取出符合该正则的链接<br>​deny, 接收一堆正则表达式, 可以剔除符合该正则的链接<br>​allow_domains: 接收一堆域名, 符合里面的域名的链接被提取<br>​deny_domains: 接收一堆域名, 剔除不符合该域名的链接<br>​restrict_xpaths: 接收一堆xpath, 可以提取符合要求xpath的链接<br>​restrict_css: 接收一堆css选择器, 可以提取符合要求的css选择器的链接<br>​tags: 接收一堆标签名, 从某个标签中提取链接, 默认a, area<br>​attrs: 接收一堆属性名, 从某个属性中提取链接, 默认href</p><p>值得注意的, &#x3D;&#x3D;在提取到的url中, 是有重复的内容的. 但是我们不用管. scrapy会自动帮我们过滤掉重复的url请求.&#x3D;&#x3D; </p><h2 id="二-使用CrawlSpider"><a href="#二-使用CrawlSpider" class="headerlink" title="二. 使用CrawlSpider"></a>二. 使用CrawlSpider</h2><p>在scrapy中提供了CrawlSpider来完成全站数据抓取. </p><ol><li><p>创建项目</p><p><code>scrapy startproject qichezhijia</code></p></li><li><p>进入项目</p><p><code>cd qichezhijia</code></p></li><li><p>创建爬虫(CrawlSpider)</p><p><code>scrapy genspider </code>&#x3D;&#x3D;-t crawl&#x3D;&#x3D;<code> ershouche che168.com</code></p><p>和以往的爬虫不同. 该爬虫需要用到crawl的模板来创建爬虫. </p></li><li><p>修改spider中的rules和回调函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErshoucheSpider</span>(<span class="title class_ inherited__">CrawlSpider</span>):</span><br><span class="line">    name = <span class="string">&#x27;ershouche&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;che168.com&#x27;</span>, <span class="string">&#x27;autohome.com.cn&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.che168.com/beijing/a0_0msdgscncgpi1ltocsp1exx0/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    le = LinkExtractor(restrict_xpaths=(<span class="string">&quot;//ul[@class=&#x27;viewlist_ul&#x27;]/li/a&quot;</span>,), deny_domains=(<span class="string">&quot;topicm.che168.com&quot;</span>,) )</span><br><span class="line">    le1 = LinkExtractor(restrict_xpaths=(<span class="string">&quot;//div[@id=&#x27;listpagination&#x27;]/a&quot;</span>,))</span><br><span class="line">    rules = (</span><br><span class="line">        Rule(le1, follow=<span class="literal">True</span>),  <span class="comment"># 单纯为了做分页</span></span><br><span class="line">        Rule(le, callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">False</span>), <span class="comment"># 单纯提取数据</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_item</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(response.url)</span><br></pre></td></tr></table></figure><p>CrawlSpider的工作流程. </p><p>前期和普通的spider是一致的. 在第一次请求回来之后. 会自动的将返回的response按照rules中订制的规则来提取链接. 并进一步执行callback中的回调. 如果follow是True, 则继续在响应的内容中继续使用该规则提取链接.  相当于在parse中的scrapy.request(xxx, callback&#x3D;self.parse)</p></li></ol><h2 id="三-Redis简单使用"><a href="#三-Redis简单使用" class="headerlink" title="三. Redis简单使用"></a>三. Redis简单使用</h2><p>​redis作为一款目前这个星球上性能最高的非关系型数据库之一. 拥有每秒近十万次的读写能力. 其实力只能用恐怖来形容. </p><ol><li><p>安装redis</p><p>redis是我见过这个星球上最好安装的软件了. 比起前面的那一坨. 它简直了…</p><p>直接把压缩包解压. 然后配置一下环境变量就可以了. </p><p><img src="/images/scrapy01/image-20210810184227132.png" alt="images/scrapy01/image-20210810184227132"></p><p><img src="/images/scrapy01/image-20210810184318301.png" alt="images/scrapy01/image-20210810184318301"></p><p>接下来, 在环境变量中将该文件夹配置到path中. </p><p><img src="/images/scrapy01/image-20210810184649037.png" alt="images/scrapy01/image-20210810184649037"></p><p>win7的同学自求多福吧…</p><p>我们给redis多配置几个东西(修改redis的配置文件, mac是: redis.conf, windows是: )</p><ol><li><p>关闭bind</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bind 127.0.0.1 ::1  # 注释掉它</span></span><br></pre></td></tr></table></figure></li><li><p>关闭保护模式  windows不用设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no    <span class="comment"># 设置为no</span></span><br></pre></td></tr></table></figure></li><li><p>设置密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass <span class="number">123456</span>   <span class="comment"># 设置密码</span></span><br></pre></td></tr></table></figure></li></ol><p>将redis怼到windows服务&#x3D;&#x3D;必须进入到redis目录后才可以&#x3D;&#x3D;</p><p><img src="/images/scrapy01/image-20210810185306517.png" alt="images/scrapy01/image-20210810185306517"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将redis安装到windows服务</span><br><span class="line">redis-server.exe --service-install redis.windows.conf --loglevel verbose</span><br><span class="line"># 卸载服务：</span><br><span class="line">redis-server --service-uninstall</span><br><span class="line"># 开启服务：</span><br><span class="line">redis-server --service-<span class="built_in">start</span></span><br><span class="line"># 停止服务：</span><br><span class="line">redis-server --service-stop</span><br></pre></td></tr></table></figure><p>使用redis-cli链接redis</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h ip地址 -p 端口 --raw   <span class="comment"># raw可以让redis显示出中文</span></span><br><span class="line">auth 密码   <span class="comment"># 如果有密码可以这样来登录, 如果没有.不用这一步</span></span><br></pre></td></tr></table></figure><p><img src="/images/scrapy01/image-20210810185605290.png" alt="images/scrapy01/image-20210810185605290"></p><p>附赠RDM, redis desktop manager. 可以帮我们完成redis数据库的可视化操作(需要就装, 不需要就算)</p><p><img src="/images/scrapy01/image-20210810185659813.png" alt="images/scrapy01/image-20210810185659813"></p></li><li><p>redis常见数据类型</p><p>redis中常见的数据类型有5个. </p><p>命令规则:  <code>命令 key 参数</code></p><ol><li><p>string</p><p>字符串(它自己认为是字符串, 我认为是任何东西. ), redis最基础的数据类型. </p><p>常用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value  <span class="comment"># 添加一条数据</span></span><br><span class="line">get key   <span class="comment"># 查看一条数据</span></span><br><span class="line">incr key       <span class="comment"># 让该key对应的数据自增1(原子性, 安全)</span></span><br><span class="line">incrby key count     <span class="comment"># 让该key对应的value自增 count </span></span><br><span class="line"><span class="built_in">type</span> key<span class="comment"># 查看数据类型(set进去的东西一律全是字符串)</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name zhangsan  <span class="comment"># 添加数据  name = zhangsan</span></span><br><span class="line">get name<span class="comment"># 查看数据 zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> age <span class="number">10</span></span><br><span class="line">get age <span class="comment"># 10</span></span><br><span class="line">incr age<span class="comment"># 11</span></span><br><span class="line">get age <span class="comment"># 11</span></span><br><span class="line">incrby age <span class="number">5</span><span class="comment"># 16</span></span><br></pre></td></tr></table></figure></li><li><p>hash</p><p>哈希, 相当于字典. </p><p>常见操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hset key k1 v1   <span class="comment"># 将k1, v1存储在key上</span></span><br><span class="line">hget key k1      <span class="comment"># 将key上的k1提取出来</span></span><br><span class="line">hmset key k1 v1 k2 v2 k3 v3....  <span class="comment"># 一次性将多个k,v存储在key</span></span><br><span class="line">hmget key k1 k2....<span class="comment"># 一次性将key中的k1, k2...提取出来</span></span><br><span class="line">hgetall key <span class="comment"># 一次性将key中所有内容全部提取</span></span><br><span class="line">hkeys key<span class="comment"># 将key中所有的k全部提取</span></span><br><span class="line">hvals key <span class="comment"># 将key中所有的v全部提取</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMSET stu <span class="built_in">id</span> <span class="number">1</span> name sylar age <span class="number">18</span></span><br><span class="line">HMGET stu name age   <span class="comment"># syalr 18</span></span><br><span class="line">HGETALL stu    <span class="comment"># id 1 name sylar age 18</span></span><br><span class="line">HKEYS stu <span class="comment"># id name age</span></span><br><span class="line">HVALS stu   <span class="comment"># 1 syalr 18</span></span><br></pre></td></tr></table></figure></li><li><p>list</p><p>列表, 底层是一个双向链表. 可以从左边和右边进行插入. 记住每次插入都要记得这货是个&#x3D;&#x3D;双向链表&#x3D;&#x3D;</p><p>常见操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key 数据<span class="number">1</span> 数据<span class="number">2</span> 数据<span class="number">3.</span>... <span class="comment"># 从左边插入数据</span></span><br><span class="line">RPUSH key 数据<span class="number">1</span> 数据<span class="number">2</span> 数据<span class="number">3.</span>... <span class="comment"># 从右边插入数据</span></span><br><span class="line">LRANGE key start stop     <span class="comment"># 从start到stop提取数据. </span></span><br><span class="line"></span><br><span class="line">LLEN key<span class="comment"># 返回key对应列表的长度</span></span><br><span class="line">LPOP key        <span class="comment"># 从左边删除一个.并返回被删除元素</span></span><br><span class="line">RPOP key<span class="comment"># 从右边删除一个.并返回被删除元素</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPUSH banji yiban erban sanban siban</span><br><span class="line">LRANGE banji <span class="number">0</span> -<span class="number">1</span>   <span class="comment"># yiban erban sanban siban</span></span><br><span class="line">RPUSH ban ban1 ban2 ban3</span><br><span class="line">LRANGE ban <span class="number">0</span> -<span class="number">1</span>     <span class="comment"># ban1 ban2 ban3</span></span><br><span class="line">LPOP ban  <span class="comment"># ban1</span></span><br><span class="line">LLEN key  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></li><li><p>set</p><p>set是无序的超大集合. 无序, 不重复. </p><p>常见操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SADD key 值   <span class="comment"># 向集合内存入数据</span></span><br><span class="line">SMEMBERS key  <span class="comment"># 查看集合内所有元素</span></span><br><span class="line">SCARD key <span class="comment"># 查看key中元素的个数</span></span><br><span class="line">SISMEMBER key val  <span class="comment"># 查看key中是否包含val</span></span><br><span class="line">SUNION key1 key2  <span class="comment"># 并集</span></span><br><span class="line">SDIFF key1 key2  <span class="comment"># 差集合, 在key1中, 但不在key2中的数据</span></span><br><span class="line">SINTER key1 key2 <span class="comment"># 计算交集, 在key1和key2中都出现了的</span></span><br><span class="line">SPOP key  <span class="comment"># 随机从key中删除一个数据</span></span><br><span class="line">SRANDMEMBER key count <span class="comment"># 随机从key中查询count个数据</span></span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SADD stars 柯震东 吴亦凡 张默 房祖名   <span class="comment"># 4</span></span><br><span class="line">SADD stars 吴亦凡    <span class="comment"># 0. 重复的数据是存储不进去的.</span></span><br><span class="line">SMEMBERS stars   <span class="comment"># 柯震东 吴亦凡 张默 房祖名</span></span><br><span class="line">SISMEMBER stars 吴亦凡  <span class="comment"># 吴亦凡在 stars里么?  1 在  0 不在</span></span><br><span class="line"></span><br><span class="line">SADD my 周杰伦 吴亦凡 房祖名  </span><br><span class="line">SINTER stars my  <span class="comment"># 计算交集  吴亦凡 房祖名</span></span><br><span class="line"></span><br><span class="line">SPOP my  <span class="comment"># 随机删除一个</span></span><br><span class="line">SRANDMEMEBER my <span class="number">2</span>   <span class="comment"># 从集合总随机查看2个</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>zset</p><p>有序集合, 有序集合中的内容也是不可以重复的. 并且存储的数据也是redis最基础的string数据. 但是在存储数据的同时还增加了一个score. 表示分值. redis就是通过这个score作为排序的规则的. </p><p>常用操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZADD key s1 m1 s2 m2 ... <span class="comment"># 向key中存入 m1 m2 分数分别为s1 s2</span></span><br><span class="line">ZRANGE key start stop [withscores]   <span class="comment"># 查看从start 到stop中的所有数据 [是否要分数]</span></span><br><span class="line">ZREVRANGE key start stop <span class="comment"># 倒叙查看start到stop的数据</span></span><br><span class="line">ZCARD key   <span class="comment"># 查看zset的数据个数</span></span><br><span class="line">ZCOUNT key <span class="built_in">min</span> <span class="built_in">max</span>  <span class="comment"># 查看分数在min和max之间的数据量</span></span><br><span class="line">ZINCRBY key score member  <span class="comment"># 将key中member的分值score</span></span><br><span class="line">ZSCORE key m  <span class="comment"># 查看key中m的分值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZADD fam <span class="number">1</span> sylar <span class="number">2</span> alex <span class="number">3</span> tory  <span class="comment"># 添加三个数据</span></span><br><span class="line">ZRANGE fam <span class="number">0</span> -<span class="number">1</span> WITHSCORES <span class="comment"># 正序查看</span></span><br><span class="line">ZREVRANGE fam <span class="number">0</span> -<span class="number">1</span> WITHSCORES   <span class="comment"># 倒叙查看</span></span><br><span class="line">ZINCRBY fam <span class="number">10</span> alex  <span class="comment"># 给alex加10分</span></span><br><span class="line">ZADD fam <span class="number">100</span> alex   <span class="comment"># 给alex修改分数为100分</span></span><br><span class="line">ZSCORE fam alex   <span class="comment"># 查看alex的分数</span></span><br><span class="line">ZCARD fam    <span class="comment"># 查看fam的数据个数</span></span><br></pre></td></tr></table></figure></li></ol><p>redis还有非常非常多的操作. 我们就不一一列举了. 各位可以在网络上找到非常多的资料. </p><p>&#x3D;&#x3D;各位大佬们注意. 数据保存完一定要save一下, 避免数据没有写入硬盘而产生的数据丢失&#x3D;&#x3D;</p></li></ol><h2 id="四-python搞定redis"><a href="#四-python搞定redis" class="headerlink" title="四. python搞定redis"></a>四. python搞定redis</h2><p>​python处理redis使用专用的redis模块. 同样的, 它也是一个第三方库.</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><p>​获取连接(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line">red = Redis(host=<span class="string">&quot;127.0.0.1&quot;</span>,  <span class="comment"># 地址</span></span><br><span class="line">            port=<span class="number">6379</span>,   <span class="comment"># 端口</span></span><br><span class="line">            db=<span class="number">0</span>,   <span class="comment"># 数据库</span></span><br><span class="line">            password=<span class="number">123456</span>,  <span class="comment"># 密码</span></span><br><span class="line">            decode_responses=<span class="literal">True</span>)  <span class="comment"># 是否自动解码</span></span><br></pre></td></tr></table></figure><p>​获取连接(2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool(</span><br><span class="line">        host=<span class="string">&quot;127.0.0.1&quot;</span>,  <span class="comment"># 地址</span></span><br><span class="line">        port=<span class="number">6379</span>,   <span class="comment"># 端口</span></span><br><span class="line">        db=<span class="number">0</span>,   <span class="comment"># 数据库</span></span><br><span class="line">        password=<span class="number">123456</span>,  <span class="comment"># 密码</span></span><br><span class="line">        decode_responses=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"><span class="built_in">print</span>(r.keys())</span><br></pre></td></tr></table></figure><p>​我们以一个免费代理IP池能用到的操作来尝试一下redis</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存入数据</span></span><br><span class="line">red.<span class="built_in">set</span>(<span class="string">&quot;sylar&quot;</span>, <span class="string">&quot;邱彦涛&quot;</span>)</span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="built_in">print</span>(red.get(<span class="string">&quot;sylar&quot;</span>))</span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张娜拉&quot;</span>]</span><br><span class="line">red.lpush(<span class="string">&quot;names&quot;</span>, *lst)  <span class="comment"># 将所有的名字都存入names</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 查询所有数据</span></span><br><span class="line">result = red.lrange(<span class="string">&quot;names&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从上面的操作上可以看出. python中的redis和redis-cli中的操作是几乎一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来, 咱们站在一个代理IP池的角度来分析各个功能</span></span><br><span class="line"><span class="comment"># 抓取到了IP. 保存入库</span></span><br><span class="line">red.zadd(<span class="string">&quot;proxy&quot;</span>, &#123;<span class="string">&quot;192.168.1.1&quot;</span>: <span class="number">10</span>, <span class="string">&quot;192.168.1.2&quot;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">red.zadd(<span class="string">&quot;proxy&quot;</span>, &#123;<span class="string">&quot;192.168.1.3&quot;</span>: <span class="number">10</span>, <span class="string">&quot;192.168.1.6&quot;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">red.zadd(<span class="string">&quot;proxy&quot;</span>, &#123;<span class="string">&quot;192.168.1.4&quot;</span>: <span class="number">10</span>, <span class="string">&quot;192.168.1.7&quot;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">red.zadd(<span class="string">&quot;proxy&quot;</span>, &#123;<span class="string">&quot;192.168.1.5&quot;</span>: <span class="number">10</span>, <span class="string">&quot;192.168.1.8&quot;</span>: <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给某一个ip增加到100分</span></span><br><span class="line">red.zadd(<span class="string">&quot;proxy&quot;</span>, &#123;<span class="string">&quot;192.168.1.4&quot;</span>: <span class="number">100</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给&quot;192.168.1.4&quot; 扣10分</span></span><br><span class="line">red.zincrby(<span class="string">&quot;proxy&quot;</span>, -<span class="number">10</span>, <span class="string">&quot;192.168.1.4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分扣没了. 删除掉它</span></span><br><span class="line">red.zrem(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;192.168.1.4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可用的代理数量</span></span><br><span class="line">c = red.zcard(<span class="string">&quot;proxy&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 根据分值进行查询(0~100)之间</span></span><br><span class="line">r = red.zrangebyscore(<span class="string">&quot;proxy&quot;</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询前100个数据(分页查询)</span></span><br><span class="line">r = red.zrevrange(<span class="string">&#x27;proxy&#x27;</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断proxy是否存在, 如果是None就是不存在</span></span><br><span class="line">r = red.zscore(<span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;192.168.1.4&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="爬虫开发" scheme="http://blog.ioimp.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Scrapy爬虫" scheme="http://blog.ioimp.top/tags/Scrapy%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
